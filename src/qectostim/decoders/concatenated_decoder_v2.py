# src/qectostim/decoders/concatenated_decoder_v2.py
"""
Proper hierarchical decoder for concatenated quantum error-correcting codes.

This module implements a correct hierarchical decoding algorithm that:

1. **Block-grouped detector structure**: Works with ConcatenatedMemoryExperiment
   which produces detectors grouped by inner code block, then outer code.

2. **Cross-correlation preservation**: When extracting per-block sub-DEMs, errors
   that correlate inner detectors with outer detectors are preserved by mapping
   outer detector correlations to virtual observables.

3. **Inner logical → outer syndrome mapping**: Inner logical errors act as
   "physical errors" on the outer code. When inner block i has a logical error,
   it flips outer syndrome bits according to column i of H_outer.

4. **Proper final correction**: The final logical correction is computed by
   XORing the outer decoder's correction with the parity of inner logicals
   that form the code's logical operator.

Key insight: For concatenated code C_outer ∘ C_inner:
- Inner logical X error on block i → Outer syndrome flips per H_z[i]
- Inner logical Z error on block i → Outer syndrome flips per H_x[i]
- Final logical = outer_decoder_output XOR (inner_logicals weighted by L_outer)
"""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional, Dict, List, Tuple, Any, TYPE_CHECKING

import numpy as np
import stim

if TYPE_CHECKING:
    from qectostim.codes.composite.concatenated import ConcatenatedCode


class HierarchicalConcatenatedDecoder:
    """
    Proper hierarchical decoder for concatenated CSS codes.
    
    This decoder requires circuits generated by ConcatenatedMemoryExperiment
    which produces block-grouped detectors.
    
    Architecture:
    - Inner decoders: One PyMatching decoder per inner block, decoding the
      block's syndrome to predict inner logical errors
    - Outer decoder: PyMatching decoder on outer code, using effective syndrome
    
    The effective outer syndrome is computed as:
        effective_syndrome = raw_outer_syndrome XOR inner_contribution
        
    where inner_contribution accounts for:
    1. Inner logical errors flipping outer detectors via H_outer
    2. Cross-block correlations from errors spanning multiple blocks
    """
    
    def __init__(
        self,
        code: 'ConcatenatedCode',
        dem: stim.DetectorErrorModel,
        rounds: int = 3,
        basis: str = "Z",
        inner_slices: Optional[Dict[int, Tuple[int, int]]] = None,
        outer_slice: Optional[Tuple[int, int]] = None,
    ):
        """
        Initialize hierarchical decoder.
        
        Parameters
        ----------
        code : ConcatenatedCode
            The concatenated code (must have _inner_code and _outer_code).
        dem : stim.DetectorErrorModel
            Full DEM from ConcatenatedMemoryExperiment.
            IMPORTANT: The DEM should have N+1 observables:
            - Observable 0: Main concatenated logical
            - Observable 1..N: Inner block 0..N-1 logical errors
        rounds : int
            Number of syndrome rounds (must match experiment).
        basis : str
            Measurement basis ('X' or 'Z').
        inner_slices : dict, optional
            Detector slices for each inner block. If None, inferred from code.
        outer_slice : tuple, optional
            (start, stop) for outer detectors. If None, inferred from code.
        """
        import pymatching
        
        self.code = code
        self.dem = dem
        self.rounds = rounds
        self.basis = basis.upper()
        self.num_detectors = dem.num_detectors
        
        # Get inner and outer codes
        # ConcatenatedCode stores .outer and .inner, not _inner_code/_outer_code
        if hasattr(code, '_inner_code') and hasattr(code, '_outer_code'):
            self.inner_code = code._inner_code
            self.outer_code = code._outer_code
        elif hasattr(code, 'inner') and hasattr(code, 'outer'):
            self.inner_code = code.inner
            self.outer_code = code.outer
        else:
            raise ValueError("Code must have inner/outer code attributes")
        
        self.n_blocks = self.outer_code.n
        
        # Check if inner code is itself concatenated (multi-level)
        from qectostim.codes.composite.concatenated import ConcatenatedCode
        self._inner_is_concatenated = isinstance(self.inner_code, ConcatenatedCode)
        
        # Check if DEM has inner logical observables
        # If num_observables == n_blocks + 1, we have inner logicals
        expected_observables = self.n_blocks + 1
        self._has_inner_logicals = (dem.num_observables >= expected_observables)
        
        if not self._has_inner_logicals:
            # Provide helpful diagnostic information
            import warnings
            warnings.warn(
                f"HierarchicalConcatenatedDecoder: DEM has {dem.num_observables} observables, "
                f"expected {expected_observables} (1 main + {self.n_blocks} inner blocks). "
                f"Inner code type: {type(self.inner_code).__name__}, "
                f"Multi-level: {self._inner_is_concatenated}"
            )
        
        # For decode output, we only return the main observable (observable 0)
        self.num_observables = 1
        
        # Get parity check matrices
        if self.basis == "Z":
            self.H_outer = np.array(self.outer_code.hz, dtype=np.uint8)
        else:
            self.H_outer = np.array(self.outer_code.hx, dtype=np.uint8)
        
        self.n_outer_stabs = self.H_outer.shape[0]
        
        # Get or compute detector slices
        if inner_slices is not None and outer_slice is not None:
            self.inner_slices = inner_slices
            self.outer_slice = outer_slice
        else:
            self._compute_detector_slices()
        
        self.n_inner_dets = self.inner_slices[0][1] - self.inner_slices[0][0] if self.inner_slices else 0
        self.n_outer_dets = self.outer_slice[1] - self.outer_slice[0]
        
        # Get outer logical operator support (needed before building outer decoder)
        self._get_outer_logical_support()
        
        # Build inner block decoders using inner logical observables
        self.inner_decoders: Dict[int, Any] = {}
        self._build_inner_decoders_with_observables(pymatching)
        
        # Build outer decoder
        self.outer_decoder = None
        self._build_outer_decoder(pymatching)
        
        # Fallback decoder for when hierarchical fails or no inner observables
        self._fallback_decoder = pymatching.Matching.from_detector_error_model(dem)
    
    def _compute_detector_slices(self) -> None:
        """Compute detector slices assuming ConcatenatedMemoryExperiment structure."""
        inner_mx = self.inner_code.hx.shape[0]
        inner_mz = self.inner_code.hz.shape[0]
        outer_mx = self.outer_code.hx.shape[0]
        outer_mz = self.outer_code.hz.shape[0]
        
        if self.basis == "Z":
            inner_x_dets = (self.rounds - 1) * inner_mx
            inner_z_dets = (self.rounds + 1) * inner_mz
            outer_x_dets = (self.rounds - 1) * outer_mx
            outer_z_dets = (self.rounds + 1) * outer_mz
        else:
            inner_x_dets = (self.rounds + 1) * inner_mx
            inner_z_dets = (self.rounds - 1) * inner_mz
            outer_x_dets = (self.rounds + 1) * outer_mx
            outer_z_dets = (self.rounds - 1) * outer_mz
        
        inner_dets_per_block = inner_x_dets + inner_z_dets
        outer_dets = outer_x_dets + outer_z_dets
        
        # Build slice dicts
        self.inner_slices = {}
        for block_id in range(self.n_blocks):
            start = block_id * inner_dets_per_block
            stop = start + inner_dets_per_block
            self.inner_slices[block_id] = (start, stop)
        
        outer_start = self.n_blocks * inner_dets_per_block
        self.outer_slice = (outer_start, outer_start + outer_dets)
    
    def _build_inner_decoders_with_observables(self, pymatching) -> None:
        """
        Build per-block inner decoders using inner logical observables from the DEM.
        
        This method extracts sub-DEMs for each inner block, where:
        - Detectors are remapped to local indices [0, n_block_dets)
        - Observable (block_id + 1) in the full DEM maps to observable 0 in the block DEM
        - This lets the inner decoder predict whether an inner logical error occurred
        
        The inner logical observables must be present in the DEM (from
        ConcatenatedMemoryExperiment._emit_inner_logical_observables).
        """
        if not self._has_inner_logicals:
            # Fall back to old method without inner logical tracking
            self._build_inner_decoders_fallback(pymatching)
            return
        
        outer_start, outer_stop = self.outer_slice
        
        for block_id in range(self.n_blocks):
            det_start, det_stop = self.inner_slices[block_id]
            inner_obs_id = block_id + 1  # Observable for this block's inner logical
            
            block_dem = stim.DetectorErrorModel()
            
            for instr in self.dem.flattened():
                if instr.type != "error":
                    continue
                
                prob = instr.args_copy()[0]
                targets = instr.targets_copy()
                
                block_dets = []
                has_other_inner = False
                has_this_inner_logical = False
                
                for t in targets:
                    if t.is_relative_detector_id():
                        det_id = t.val
                        if det_start <= det_id < det_stop:
                            # Detector in this block - remap to local index
                            local_id = det_id - det_start
                            block_dets.append(stim.target_relative_detector_id(local_id))
                        elif outer_start <= det_id < outer_stop:
                            # Outer detector - skip for inner block decoder
                            pass
                        else:
                            # Another inner block - don't include this error
                            has_other_inner = True
                            break
                    elif t.is_logical_observable_id():
                        if t.val == inner_obs_id:
                            # This error affects this block's inner logical
                            has_this_inner_logical = True
                        # Ignore observable 0 (main logical) for inner decoders
                
                # Include error if it affects this block and doesn't span other blocks
                if block_dets and not has_other_inner:
                    targets_for_block = block_dets
                    if has_this_inner_logical:
                        # Map inner logical to observable 0 in block DEM
                        targets_for_block.append(stim.target_logical_observable_id(0))
                    block_dem.append("error", prob, targets_for_block)
            
            # Build decoder for this block
            if block_dem.num_errors > 0:
                try:
                    self.inner_decoders[block_id] = pymatching.Matching.from_detector_error_model(block_dem)
                except Exception as e:
                    # Matching build can fail for various reasons
                    self.inner_decoders[block_id] = None
            else:
                self.inner_decoders[block_id] = None
    
    def _build_inner_decoders_fallback(self, pymatching) -> None:
        """
        Fallback method for building inner decoders when no inner logical observables.
        
        This uses the old approach with virtual observables for outer correlations,
        which doesn't work well because it can't track true inner logical errors.
        """
        outer_start, outer_stop = self.outer_slice
        self.inner_outer_correlations: Dict[int, Dict[int, int]] = {}
        
        for block_id in range(self.n_blocks):
            det_start, det_stop = self.inner_slices[block_id]
            
            block_dem = stim.DetectorErrorModel()
            outer_corr_map: Dict[int, int] = {}
            next_virtual = 1
            
            for instr in self.dem.flattened():
                if instr.type != "error":
                    continue
                
                prob = instr.args_copy()[0]
                targets = instr.targets_copy()
                
                block_dets = []
                outer_dets = []
                other_inner_block = False
                logical_targets = []
                
                for t in targets:
                    if t.is_relative_detector_id():
                        det_id = t.val
                        if det_start <= det_id < det_stop:
                            local_id = det_id - det_start
                            block_dets.append(stim.target_relative_detector_id(local_id))
                        elif outer_start <= det_id < outer_stop:
                            outer_dets.append(det_id)
                        else:
                            other_inner_block = True
                    elif t.is_logical_observable_id():
                        logical_targets.append(t)
                
                if block_dets and not other_inner_block:
                    virtual_targets = []
                    for outer_det in outer_dets:
                        if outer_det not in outer_corr_map:
                            outer_corr_map[outer_det] = next_virtual
                            next_virtual += 1
                        virtual_targets.append(
                            stim.target_logical_observable_id(outer_corr_map[outer_det])
                        )
                    
                    all_targets = block_dets + logical_targets + virtual_targets
                    block_dem.append("error", prob, all_targets)
            
            self.inner_outer_correlations[block_id] = {
                v: k for k, v in outer_corr_map.items()
            }
            
            if block_dem.num_errors > 0:
                try:
                    self.inner_decoders[block_id] = pymatching.Matching.from_detector_error_model(block_dem)
                except Exception:
                    self.inner_decoders[block_id] = None
            else:
                self.inner_decoders[block_id] = None

    def _build_inner_decoders(self, pymatching) -> None:
        """
        Build per-block inner decoders with cross-correlation tracking.
        
        For each inner block, we extract a sub-DEM containing:
        - All errors that affect ONLY this block's detectors
        - Errors that affect this block + outer detectors (with outer correlations
          mapped to virtual observables)
        
        The virtual observables tell us which outer detectors are correlated with
        errors in this block, enabling proper syndrome mapping.
        """
        outer_start, outer_stop = self.outer_slice
        
        for block_id in range(self.n_blocks):
            det_start, det_stop = self.inner_slices[block_id]
            n_block_dets = det_stop - det_start
            
            # Extract block DEM with outer correlations as virtual observables
            block_dem = stim.DetectorErrorModel()
            outer_corr_map: Dict[int, int] = {}  # outer_det_global -> virtual_obs_id
            next_virtual = 1  # obs 0 is the actual inner logical
            
            for instr in self.dem.flattened():
                if instr.type != "error":
                    continue
                
                prob = instr.args_copy()[0]
                targets = instr.targets_copy()
                
                block_dets = []  # Detectors in this block (remapped to local)
                outer_dets = []  # Outer detectors correlated with this error
                other_inner_block = False  # True if error spans other inner blocks
                logical_targets = []
                
                for t in targets:
                    if t.is_relative_detector_id():
                        det_id = t.val
                        if det_start <= det_id < det_stop:
                            # In this block
                            local_id = det_id - det_start
                            block_dets.append(stim.target_relative_detector_id(local_id))
                        elif outer_start <= det_id < outer_stop:
                            # Outer detector
                            outer_dets.append(det_id)
                        else:
                            # Another inner block - don't include in this block's decoder
                            other_inner_block = True
                    elif t.is_logical_observable_id():
                        logical_targets.append(t)
                
                # Only include if this error affects this block and doesn't span other inner blocks
                if block_dets and not other_inner_block:
                    # Map outer detector correlations to virtual observables
                    virtual_targets = []
                    for outer_det in outer_dets:
                        if outer_det not in outer_corr_map:
                            outer_corr_map[outer_det] = next_virtual
                            next_virtual += 1
                        virtual_targets.append(
                            stim.target_logical_observable_id(outer_corr_map[outer_det])
                        )
                    
                    all_targets = block_dets + logical_targets + virtual_targets
                    block_dem.append("error", prob, all_targets)
            
            # Store correlation map (inverse: virtual_obs -> outer_det_global)
            self.inner_outer_correlations[block_id] = {
                v: k for k, v in outer_corr_map.items()
            }
            
            # Build decoder for this block
            if block_dem.num_errors > 0:
                try:
                    # Set number of observables to include virtual ones
                    n_obs = next_virtual  # 0 = logical, 1+ = virtual outer correlations
                    self.inner_decoders[block_id] = pymatching.Matching.from_detector_error_model(block_dem)
                except Exception as e:
                    print(f"Warning: Failed to build inner decoder for block {block_id}: {e}")
                    self.inner_decoders[block_id] = None
            else:
                self.inner_decoders[block_id] = None
    
    def _build_outer_decoder(self, pymatching) -> None:
        """
        Build outer decoder using phenomenological model from outer code structure.
        
        Instead of extracting only pure-outer edges (which loses most error info),
        we build a phenomenological DEM directly from the outer code's parity check.
        This ensures the outer decoder can correct inner logical errors that act
        as "physical errors" on the outer code.
        
        The outer decoder handles:
        - Inner logical errors (mapped to outer syndrome via H_outer)
        - Measurement errors on outer ancillas (captured via phenomenological model)
        """
        outer_start, outer_stop = self.outer_slice
        n_outer_dets = outer_stop - outer_start
        
        # Strategy: Build phenomenological outer DEM from H_outer
        # Each inner block (column of H_outer) can have a logical error
        # that flips the stabilizers (rows of H_outer) it participates in.
        outer_dem = stim.DetectorErrorModel()
        
        # Add phenomenological errors: one per inner block (outer code "qubit")
        # Error on block i flips detectors according to H_outer[:, i]
        p_phenom = 0.01  # Nominal probability (actual weights come from inner decoders)
        
        n_stabs = self.H_outer.shape[0]
        n_qubits = min(self.H_outer.shape[1], self.n_blocks)
        
        for q in range(n_qubits):
            affected_stabs = np.where(self.H_outer[:, q] == 1)[0]
            if len(affected_stabs) > 0:
                # Map to local detector indices
                # Outer detectors are organized similarly to inner:
                # We assume outer stabilizer i maps to detector i (simplified)
                targets = []
                for s in affected_stabs:
                    if s < n_outer_dets:
                        targets.append(stim.target_relative_detector_id(s))
                
                if targets:
                    # Check if this qubit is in logical support
                    if q in self.outer_logical_support:
                        targets.append(stim.target_logical_observable_id(0))
                    outer_dem.append("error", p_phenom, targets)
        
        # Also add pure measurement errors from the original DEM
        # These are errors affecting only outer detectors
        for instr in self.dem.flattened():
            if instr.type != "error":
                continue
            
            prob = instr.args_copy()[0]
            targets = instr.targets_copy()
            
            outer_dets = []
            has_inner = False
            logical_targets = []
            
            for t in targets:
                if t.is_relative_detector_id():
                    det_id = t.val
                    if outer_start <= det_id < outer_stop:
                        local_id = det_id - outer_start
                        outer_dets.append(stim.target_relative_detector_id(local_id))
                    else:
                        has_inner = True
                        break
                elif t.is_logical_observable_id():
                    logical_targets.append(t)
            
            # Include pure-outer measurement errors
            if outer_dets and not has_inner:
                all_targets = outer_dets + logical_targets
                outer_dem.append("error", prob, all_targets)
        
        if outer_dem.num_errors > 0:
            try:
                self.outer_decoder = pymatching.Matching.from_detector_error_model(outer_dem)
            except Exception as e:
                # Fallback: try BPOSD if available
                try:
                    from stimbposd import BPOSD
                    self.outer_decoder = BPOSD(outer_dem)
                except Exception:
                    import warnings
                    warnings.warn(f"Failed to build outer decoder: {e}")
                    self.outer_decoder = None
        else:
            self.outer_decoder = None
    
    def _get_outer_logical_support(self) -> None:
        """
        Get which blocks contribute to the outer logical operator.
        
        For Z-basis, this is the support of Z_L (outer).
        For X-basis, this is the support of X_L (outer).
        """
        self.outer_logical_support = set()
        
        try:
            if self.basis == "Z":
                # Z logical - support in z_ops
                if hasattr(self.outer_code, 'z_ops') and self.outer_code.z_ops:
                    L = self.outer_code.z_ops[0]
                    for i in range(self.outer_code.n):
                        if L[i] != 0:  # Assuming Z or Y
                            self.outer_logical_support.add(i)
                else:
                    # Fallback: all qubits
                    self.outer_logical_support = set(range(self.outer_code.n))
            else:
                # X logical
                if hasattr(self.outer_code, 'x_ops') and self.outer_code.x_ops:
                    L = self.outer_code.x_ops[0]
                    for i in range(self.outer_code.n):
                        if L[i] != 0:  # Assuming X or Y
                            self.outer_logical_support.add(i)
                else:
                    self.outer_logical_support = set(range(self.outer_code.n))
        except Exception:
            # Fallback: all blocks
            self.outer_logical_support = set(range(self.n_blocks))
    
    def decode_batch(self, dets: np.ndarray) -> np.ndarray:
        """
        Decode batch of syndrome samples using hierarchical algorithm.
        
        Algorithm (when inner logical observables are available):
        1. For each inner block, decode to get inner logical prediction
        2. Compute effective outer syndrome:
           - Start with raw outer syndrome
           - XOR with contributions from inner logicals (via H_outer)
        3. Decode outer with effective syndrome
        4. Compute final logical:
           - XOR outer decoder output with parity of inner logicals in L_outer support
        
        Parameters
        ----------
        dets : np.ndarray
            Shape (n_shots, n_detectors) detector outcomes.
            
        Returns
        -------
        np.ndarray
            Shape (n_shots, 1) logical corrections (only main observable).
        """
        dets = np.asarray(dets, dtype=np.uint8)
        if dets.ndim == 1:
            dets = dets.reshape(1, -1)
        
        n_shots = dets.shape[0]
        
        if dets.shape[1] != self.num_detectors:
            raise ValueError(f"Expected {self.num_detectors} detectors, got {dets.shape[1]}")
        
        # =====================================================================
        # Use proper hierarchical decoding - NO FALLBACK ALLOWED
        # =====================================================================
        if not self._has_inner_logicals:
            raise ValueError(
                "HierarchicalConcatenatedDecoder requires inner logical observables in the DEM. "
                f"Expected {self.n_blocks + 1} observables (1 main + {self.n_blocks} inner blocks), "
                f"but DEM has {self.dem.num_observables}. "
                "Use ConcatenatedMemoryExperiment to generate circuits with inner logical observables."
            )
        
        # Check if we have working inner decoders
        has_working_inner = any(d is not None for d in self.inner_decoders.values())
        if not has_working_inner:
            raise ValueError(
                "HierarchicalConcatenatedDecoder failed to build any inner decoders. "
                "Check that the DEM has proper block structure and inner logical observables."
            )
        
        # =====================================================================
        # Step 1: Decode each inner block to get inner logical predictions
        # =====================================================================
        inner_logicals = np.zeros((n_shots, self.n_blocks), dtype=np.uint8)
        
        for block_id in range(self.n_blocks):
            if block_id not in self.inner_slices:
                continue
            
            det_start, det_stop = self.inner_slices[block_id]
            block_syndrome = dets[:, det_start:det_stop]
            
            decoder = self.inner_decoders.get(block_id)
            if decoder is None:
                continue
            
            try:
                # Decode this block - observable 0 = inner logical for this block
                result = decoder.decode_batch(block_syndrome)
                result = np.atleast_2d(result)
                
                if result.shape[1] > 0:
                    inner_logicals[:, block_id] = result[:, 0]
            except Exception:
                # Block decoding failed - assume no inner logical error
                pass
        
        # =====================================================================
        # Step 2: Compute effective outer syndrome
        # =====================================================================
        outer_start, outer_stop = self.outer_slice
        raw_outer_syndrome = dets[:, outer_start:outer_stop]
        
        # Inner logical error on block i → flip outer syndrome per H_outer[:, i]
        # effective_syndrome[shot, stab] = raw[shot, stab] XOR sum_i(inner_logicals[shot, i] * H[stab, i])
        n_blocks_to_use = min(self.n_blocks, self.H_outer.shape[1])
        n_stabs_to_use = min(self.n_outer_stabs, raw_outer_syndrome.shape[1])
        
        # Compute inner contribution to outer syndrome
        inner_syndrome_contrib = (inner_logicals[:, :n_blocks_to_use] @ 
                                  self.H_outer[:n_stabs_to_use, :n_blocks_to_use].T) % 2
        inner_syndrome_contrib = inner_syndrome_contrib.astype(np.uint8)
        
        effective_syndrome = raw_outer_syndrome.copy()
        effective_syndrome[:, :n_stabs_to_use] ^= inner_syndrome_contrib
        
        # =====================================================================
        # Step 3: Decode outer code with effective syndrome
        # =====================================================================
        if self.outer_decoder is not None:
            try:
                outer_result = self.outer_decoder.decode_batch(effective_syndrome)
                outer_result = np.atleast_2d(outer_result)
                outer_logical = outer_result[:, 0] if outer_result.shape[1] > 0 else np.zeros(n_shots, dtype=np.uint8)
            except Exception:
                # Outer decoding failed - use majority vote on inner logicals
                outer_logical = (np.sum(inner_logicals, axis=1) > self.n_blocks // 2).astype(np.uint8)
        else:
            # No outer decoder - use majority vote
            outer_logical = (np.sum(inner_logicals, axis=1) > self.n_blocks // 2).astype(np.uint8)
        
        # =====================================================================
        # Step 4: Compute final logical correction
        # =====================================================================
        # Final logical = outer_result XOR parity(inner_logicals in L_outer support)
        # This accounts for inner logical errors that directly flip the concatenated logical
        
        inner_parity = np.zeros(n_shots, dtype=np.uint8)
        for block_id in self.outer_logical_support:
            if block_id < self.n_blocks:
                inner_parity ^= inner_logicals[:, block_id]
        
        final_logical = (outer_logical ^ inner_parity).astype(np.uint8)
        
        return final_logical.reshape(-1, 1)
    
    def decode(self, dets: np.ndarray) -> np.ndarray:
        """Decode single syndrome sample."""
        return self.decode_batch(dets.reshape(1, -1)).flatten()


def create_hierarchical_decoder(
    code: 'ConcatenatedCode',
    dem: stim.DetectorErrorModel,
    rounds: int = 3,
    basis: str = "Z",
    detector_slices: Optional[Dict[str, Any]] = None,
) -> HierarchicalConcatenatedDecoder:
    """
    Factory function to create a hierarchical concatenated decoder.
    
    Parameters
    ----------
    code : ConcatenatedCode
        The concatenated code.
    dem : stim.DetectorErrorModel
        DEM from ConcatenatedMemoryExperiment.
    rounds : int
        Number of syndrome rounds.
    basis : str
        Measurement basis.
    detector_slices : dict, optional
        Pre-computed detector slices from experiment.get_detector_slices().
        
    Returns
    -------
    HierarchicalConcatenatedDecoder
        Ready-to-use hierarchical decoder.
    """
    inner_slices = None
    outer_slice = None
    
    if detector_slices is not None:
        inner_slices = detector_slices.get('inner_slices')
        outer_slices = detector_slices.get('outer_slices')
        if outer_slices:
            outer_slice = outer_slices.get(0)
    
    return HierarchicalConcatenatedDecoder(
        code=code,
        dem=dem,
        rounds=rounds,
        basis=basis,
        inner_slices=inner_slices,
        outer_slice=outer_slice,
    )
