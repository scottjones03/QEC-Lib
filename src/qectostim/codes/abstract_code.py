# src/qec_to_stim/codes/abstract_code.py
from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from .abstract_css import CSSCode

PauliString = Dict[int, str]  # e.g. {0: 'X', 3: 'Z'} means X on qubit0, Z on qubit3
Coord = Tuple[float, ...]  # D-dimensional coordinates


@dataclass
class CellEmbedding:
    """Embedding of cells of a given grade into D-dimensional space."""
    grade: int
    coords: List[Coord]   # length = dim(C_grade)


class Code(ABC):
    """
    Abstract base class for ANY quantum code (stabilizer, subsystem, homological, etc.).
    This is the interface Experiments talk to.
    """

    @property
    @abstractmethod
    def n(self) -> int:
        """Number of physical qubits."""

    @property
    @abstractmethod
    def k(self) -> int:
        """Number of logical qubits."""

    @property
    def name(self) -> str:
        return self.__class__.__name__

    @property
    def metadata(self) -> Dict[str, Any]:
        """Arbitrary metadata associated with the code instance."""
        return getattr(self, "_metadata", {})

    @metadata.setter
    def metadata(self, value: Dict[str, Any]) -> None:
        self._metadata = value

    # --- Logical operators ---

    @abstractmethod
    def logical_x_ops(self) -> List[PauliString]:
        """Logical X operators (one per logical qubit)."""

    @abstractmethod
    def logical_z_ops(self) -> List[PauliString]:
        """Logical Z operators (one per logical qubit)."""

    # --- Stabilizers / gauge ---

    @abstractmethod
    def stabilizers(self) -> List[PauliString]:
        """List of stabilizer generators as Pauli strings."""

    def gauge_ops(self) -> List[PauliString]:
        """Optional: gauge operators if this is a subsystem code."""
        return []

    # --- Geometry / metadata (optional but useful) ---

    def qubit_coords(self) -> Optional[List[Tuple[float, float]]]:
        """
        Optional 2D embedding for visualization / nearest-neighbour constraints.
        None if not defined.
        """
        return None

    # --- Homological / CSS-specific accessors (may be overridden) ---

    def as_css(self) -> Optional["CSSCode"]:
        """Return self as a CSSCode if applicable, else None."""
        return None

    def extra_metadata(self) -> Dict[str, Any]:
        """Arbitrary metadata for advanced use."""
        return {}


class StabilizerCode(Code):
    """
    Abstract base class for stabilizer codes (both CSS and non-CSS).
    
    A stabilizer code is defined by:
    - A stabilizer group generated by commuting Pauli operators
    - Logical operators that commute with stabilizers but not with each other
    
    The stabilizer generators are stored in symplectic form as a matrix
    [X_part | Z_part] where each row is a stabilizer generator.
    
    For a code on n qubits with m stabilizer generators:
    - stabilizer_matrix has shape (m, 2*n)
    - First n columns: X components (1 if X or Y on that qubit)
    - Last n columns: Z components (1 if Z or Y on that qubit)
    
    Subclasses:
    - CSSCode: Stabilizers factor into pure X-type and pure Z-type
    - NonCSSStabilizerCode: Mixed X/Z stabilizers (e.g., [[5,1,3]] Perfect Code)
    """
    
    @property
    @abstractmethod
    def stabilizer_matrix(self) -> np.ndarray:
        """
        Stabilizer generators in symplectic form.
        
        Returns
        -------
        np.ndarray
            Shape (m, 2*n) where m = number of stabilizers, n = number of qubits.
            Format: [X_part | Z_part] where X_part[i,j]=1 means X on qubit j,
            Z_part[i,j]=1 means Z on qubit j. Both 1 means Y.
        """
    
    @property
    def is_css(self) -> bool:
        """
        Check if this is a CSS code (all stabilizers are pure X-type or pure Z-type).
        
        Returns True if every stabilizer generator has support on only X or only Z
        (but not both, except for identity).
        """
        stab_mat = self.stabilizer_matrix
        if stab_mat.size == 0:
            return True
        
        n = self.n
        x_part = stab_mat[:, :n]
        z_part = stab_mat[:, n:]
        
        # Check each stabilizer: it's CSS if x_support and z_support don't overlap
        # or one of them is empty
        for i in range(stab_mat.shape[0]):
            has_x = np.any(x_part[i] != 0)
            has_z = np.any(z_part[i] != 0)
            if has_x and has_z:
                # Has both X and Z - not CSS unless they're the same (which would be Y)
                # For CSS, we require each stab to be EITHER pure X OR pure Z
                return False
        return True
    
    def stabilizers(self) -> List[PauliString]:
        """
        Convert stabilizer matrix to list of Pauli strings.
        
        Returns
        -------
        List[PauliString]
            Each dict maps qubit index to Pauli type ('X', 'Y', 'Z').
        """
        stab_mat = self.stabilizer_matrix
        if stab_mat.size == 0:
            return []
        
        n = self.n
        x_part = stab_mat[:, :n]
        z_part = stab_mat[:, n:]
        
        stabs = []
        for i in range(stab_mat.shape[0]):
            pauli: PauliString = {}
            for j in range(n):
                x_bit = x_part[i, j]
                z_bit = z_part[i, j]
                if x_bit and z_bit:
                    pauli[j] = 'Y'
                elif x_bit:
                    pauli[j] = 'X'
                elif z_bit:
                    pauli[j] = 'Z'
            stabs.append(pauli)
        return stabs
    
    def x_stabilizers(self) -> List[PauliString]:
        """
        Get stabilizers that are pure X-type (only X operators).
        
        For CSS codes, this returns the X-type stabilizer generators.
        For non-CSS codes, this returns stabilizers with only X components.
        """
        return [s for s in self.stabilizers() if all(p == 'X' for p in s.values())]
    
    def z_stabilizers(self) -> List[PauliString]:
        """
        Get stabilizers that are pure Z-type (only Z operators).
        
        For CSS codes, this returns the Z-type stabilizer generators.
        For non-CSS codes, this returns stabilizers with only Z components.
        """
        return [s for s in self.stabilizers() if all(p == 'Z' for p in s.values())]
    
    def mixed_stabilizers(self) -> List[PauliString]:
        """
        Get stabilizers that have both X and Z components.
        
        For CSS codes, this returns an empty list.
        For non-CSS codes, this returns stabilizers with mixed X/Z/Y operators.
        """
        stabs = self.stabilizers()
        mixed = []
        for s in stabs:
            paulis = set(s.values())
            if len(paulis) > 1 or 'Y' in paulis:
                mixed.append(s)
        return mixed


class SubsystemCode(StabilizerCode):
    """
    Abstract base class for subsystem codes.
    
    A subsystem code has:
    - Gauge group G: contains gauge operators (not all commute with each other)
    - Stabilizer group S = center(G) âˆ© Pauli_n: center of gauge group
    - Logical operators: operators in normalizer(S) but not in G
    
    The key advantage is that syndrome extraction only requires measuring
    gauge operators (often weight-2) rather than full stabilizers.
    
    Subclasses should implement:
    - gauge_matrix: gauge operators in symplectic form
    - stabilizer_matrix: (optional) computed from gauge_matrix as products
    """
    
    @property
    @abstractmethod
    def gauge_matrix(self) -> np.ndarray:
        """
        Gauge operators in symplectic form.
        
        Returns
        -------
        np.ndarray
            Shape (g, 2*n) where g = number of gauge generators.
            Same format as stabilizer_matrix.
        """
    
    def gauge_ops(self) -> List[PauliString]:
        """Convert gauge matrix to list of Pauli strings."""
        gauge_mat = self.gauge_matrix
        if gauge_mat.size == 0:
            return []
        
        n = self.n
        x_part = gauge_mat[:, :n]
        z_part = gauge_mat[:, n:]
        
        gauges = []
        for i in range(gauge_mat.shape[0]):
            pauli: PauliString = {}
            for j in range(n):
                x_bit = x_part[i, j]
                z_bit = z_part[i, j]
                if x_bit and z_bit:
                    pauli[j] = 'Y'
                elif x_bit:
                    pauli[j] = 'X'
                elif z_bit:
                    pauli[j] = 'Z'
            gauges.append(pauli)
        return gauges
