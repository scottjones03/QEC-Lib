"""Floquet Codes — Dynamically Generated Quantum Error-Correcting Codes

Floquet codes are **dynamical** codes where the effective stabiliser
group emerges from a **time-periodic measurement schedule** rather
than being statically defined.  The instantaneous stabiliser group
(ISG) changes each round, but after one full period the code returns
to the same ISG.

Overview
--------
In a standard stabiliser code, the stabiliser generators are fixed and
measured simultaneously.  In a Floquet code:

1. Only **weight-2** check operators are measured each round.
2. These checks cycle through different Pauli types (XX, YY, ZZ) on
   different edge sets of the underlying lattice.
3. After a full period of measurements, the accumulated information
   defines an effective distance-*d* code.

This approach is **inherently fault-tolerant**: the measurement circuit
*is* the code — there are no separate stabiliser-measurement ancillas.

Code parameters (Honeycomb example)
-----------------------------------
* **n** = 2 · rows · cols  data qubits (2 per unit cell)
* **k** = 1  logical qubit (for the honeycomb code)
* **d** = min(rows, cols)  code distance
* **Period** = 3 measurement rounds (XX → YY → ZZ)

Instantaneous stabiliser group (ISG)
------------------------------------
At any point in the schedule the ISG is the group generated by all
check outcomes accumulated so far.  For the honeycomb code:

* After round 1 (XX): ISG includes XX pairs on red edges.
* After round 2 (YY): ISG grows to include emergent plaquettes.
* After round 3 (ZZ): ISG = full surface-code-like stabiliser group.

The ISG may **not** satisfy the CSS constraint ``Hx · Hz^T = 0``
because the X- and Z-type checks at any single instant are not
necessarily the final effective stabilisers.  The ``FloquetCode``
base class therefore **bypasses CSS validation**.

Classes in this module
----------------------
* ``FloquetCode`` — base class; relaxes CSS validation.
* ``HoneycombCode`` — Hastings–Haah honeycomb Floquet code.
* ``ISGFloquetCode`` — generic ISG Floquet code framework.

Fault tolerance
---------------
Because every check is weight-2, the measurement circuit is
inherently transversal — no ancilla is needed and hook errors
do not arise.  This makes Floquet codes especially hardware-friendly.

Code Parameters
~~~~~~~~~~~~~~~
Floquet codes have **dynamic** ``[[n, k, d]]`` parameters that depend on
the measurement schedule and the instantaneous stabiliser group (ISG):

* **HoneycombCode**: ``n = 2 * rows * cols``, ``k = 1``,
  ``d = min(rows, cols)``.  Period = 3 rounds (XX → YY → ZZ).
* **ISGFloquetCode**: ``n = d(d+1)/2 + d`` (approx), ``k = 1``,
  ``d = base_distance``.  Period = 2 rounds (XX → ZZ).

The effective code distance is only achieved after a full period of
measurements.  Mid-period, the ISG may have distance 0.

Stabiliser Structure
~~~~~~~~~~~~~~~~~~~~
Unlike static stabiliser codes, Floquet codes have a **time-varying**
stabiliser group:

* **Check weight**: all checks are **weight-2** (two-body measurements),
  eliminating ancilla hook errors.
* **ISG evolution**: the instantaneous stabiliser group grows with each
  measurement round.  After one full period, the ISG is equivalent to a
  surface-code-like stabiliser group.
* **Emergent plaquettes**: higher-weight stabilisers (plaquettes) emerge
  as products of accumulated weight-2 check outcomes.
* **Measurement schedule**: checks cycle through different Pauli types
  on different edge sets of the underlying lattice (e.g. XX, YY, ZZ
  on red, green, blue edges of a honeycomb lattice).
* **CSS constraint**: the ISG at any single time-step may **not**
  satisfy ``Hx @ Hz^T = 0``, since X and Z checks from different rounds
  can anti-commute.  The full-period ISG does satisfy CSS.

Connections to other codes
--------------------------
* **Surface codes**: the effective ISG of the honeycomb code at the
  end of a full period is equivalent to a surface code.
* **Colour codes**: the Floquet colour code extends the idea to
  three-colourable lattices.
* **Subsystem codes**: each measurement round can be viewed as a
  gauge measurement of a subsystem code.

References
----------
* Hastings & Haah, "Dynamically Generated Logical Qubits",
  Quantum 5, 564 (2021).  arXiv:2107.02194
* Gidney, Newman & Brooks, "Benchmarking the Planar Honeycomb
  Code", Quantum 6, 813 (2022).  arXiv:2202.11845
* Haah & Hastings, "Boundaries for the Honeycomb Code",
  Quantum 6, 693 (2022).  arXiv:2110.09545
* Error Correction Zoo: https://errorcorrectionzoo.org/c/floquet_color

Decoding
--------
* The detector error model for a Floquet code is inherently space-time:
  detectors compare measurement outcomes across consecutive rounds.
* MWPM (PyMatching) works on the resulting detector graph.
* Because checks are weight-2, each measurement outcome is a simple
  parity of two data qubits — no ancilla hook errors exist.

Implementation notes
--------------------
* The ISG may temporarily have distance 0 mid-period; only the full-
  period ISG guarantees the advertised code distance.
* Boundary conditions must be chosen carefully to avoid spurious
  degeneracies in the ISG at intermediate rounds.
* In hardware, the 3-round period maps naturally to a 3-step
  entangling-gate schedule on a hexagonal qubit connectivity graph.
"""

from __future__ import annotations
import warnings
from typing import Dict, Any, List, Optional, Tuple
from abc import abstractmethod

import numpy as np

from qectostim.codes.abstract_css import CSSCode
from qectostim.codes.abstract_code import PauliString
from qectostim.codes.utils import compute_css_logicals, vectors_to_paulis_x, vectors_to_paulis_z


class FloquetCode(CSSCode):
    """
    Base class for Floquet (dynamical) codes.
    
    Floquet codes are dynamical codes where stabilizers are measured in a 
    time-periodic sequence. The effective logical qubits emerge from the
    measurement schedule rather than from static stabilizers.
    
    Key differences from static CSS codes:
    1. The CSS constraint (Hx @ Hz.T = 0) is relaxed for the instantaneous
       stabilizer group representation
    2. Measurement schedules define the code behavior, not just Hx/Hz
    3. The distance may be schedule-dependent
    
    This base class provides:
    - Relaxed CSS validation (no commutativity check)
    - Floquet-specific metadata
    - Interface for measurement schedules (subclasses implement)
    
    Parameters
    ----------
    hx : np.ndarray
        X-type check matrix (instantaneous)
    hz : np.ndarray
        Z-type check matrix (instantaneous)
    logical_x : List[PauliString]
        X-type logical operators
    logical_z : List[PauliString]
        Z-type logical operators
    metadata : Dict[str, Any], optional
        Additional code metadata
    """
    
    def __init__(
        self,
        hx: np.ndarray,
        hz: np.ndarray,
        logical_x: List[PauliString],
        logical_z: List[PauliString],
        metadata: Optional[Dict[str, Any]] = None
    ):
        """Initialise a Floquet code from instantaneous check matrices.

        CSS commutativity (``Hx @ Hz.T = 0``) is deliberately **not**
        enforced because the ISG at any single time-step may mix X and
        Z checks that do not commute pairwise.

        Parameters
        ----------
        hx : np.ndarray
            X-type check matrix of the instantaneous stabiliser group.
        hz : np.ndarray
            Z-type check matrix of the instantaneous stabiliser group.
        logical_x : list of PauliString
            X-type logical operators.
        logical_z : list of PauliString
            Z-type logical operators.
        metadata : dict, optional
            Extra key/value pairs merged into the code's metadata dict.

        Raises
        ------
        ValueError
            If ``hx`` and ``hz`` have different numbers of columns
            (i.e. refer to different qubit counts).
        """
        # Store matrices directly, bypassing CSS validation
        self._hx = np.array(hx, dtype=np.uint8)
        self._hz = np.array(hz, dtype=np.uint8)
        self._logical_x = logical_x
        self._logical_z = logical_z
        
        # Set up metadata with floquet flag
        meta = dict(metadata or {})
        meta["is_floquet"] = True
        meta["is_dynamical"] = True
        meta.setdefault("type", "floquet")
        # Floquet codes use non-standard testing (ISG doesn't satisfy CSS constraint)
        meta["skip_standard_test"] = True
        # Set default standard metadata keys for Floquet codes
        meta.setdefault("code_family", "floquet")
        meta.setdefault("code_type", "floquet")
        meta.setdefault("error_correction_zoo_url", "https://errorcorrectionzoo.org/c/floquet_color")
        meta.setdefault("wikipedia_url", None)
        meta.setdefault("canonical_references", [
            "Hastings & Haah, 'Dynamically Generated Logical Qubits' (2021)",
        ])
        meta.setdefault("connections", [
            "Dynamical code: stabilizers emerge from periodic measurement schedule",
        ])
        meta.setdefault("stabiliser_schedule", None)
        meta.setdefault("x_schedule", None)
        meta.setdefault("z_schedule", None)
        meta.setdefault("lx_pauli_type", None)
        meta.setdefault("lz_pauli_type", None)
        meta.setdefault("lx_support", None)
        meta.setdefault("lz_support", None)
        meta.setdefault("rate", None)
        self._metadata = meta
        
        # Validate dimensions only (not commutativity)
        self._validate_floquet()
    
    def _validate_floquet(self) -> None:
        """Validate Floquet code structure (dimensions only, no commutativity)."""
        if self._hx.size == 0 and self._hz.size == 0:
            return
        
        if self._hx.size > 0 and self._hz.size > 0:
            if self._hx.shape[1] != self._hz.shape[1]:
                raise ValueError(
                    f"Hx has {self._hx.shape[1]} columns, Hz has {self._hz.shape[1]} columns. "
                    "Both must have the same number of qubits."
                )
        
        # Log commutativity status for debugging (but don't error)
        if self._hx.size > 0 and self._hz.size > 0:
            comm = (self._hx @ self._hz.T) % 2
            if np.any(comm):
                # This is expected for Floquet codes - just note it in metadata
                self._metadata["css_commutes"] = False
            else:
                self._metadata["css_commutes"] = True
    
    def _validate_css(self) -> None:
        """Override CSS validation - Floquet codes don't require Hx @ Hz.T = 0."""
        # Skip the commutativity check - use _validate_floquet instead
        pass
    
    @property
    def name(self) -> str:
        """Human-readable name derived from metadata."""
        return self._metadata.get("name", f"FloquetCode(n={self.n})")

    @property
    def distance(self) -> int:
        """Code distance (schedule-dependent; stored in metadata)."""
        return self._metadata.get("distance", 1)

    def qubit_coords(self) -> List:
        """Return qubit coordinates (if available in metadata)."""
        return self._metadata.get("data_coords", list(range(self.n)))

    @property
    def measurement_schedule(self) -> Optional[List[str]]:
        """Return the measurement schedule for this Floquet code.
        
        Subclasses should override this to provide the actual schedule.
        
        Returns
        -------
        List[str] or None
            List of measurement types per round (e.g., ['XX', 'YY', 'ZZ'])
        """
        return self._metadata.get("measurement_schedule", None)
    
    @property
    def period(self) -> int:
        """Return the period of the measurement schedule.
        
        Returns
        -------
        int
            Number of measurement rounds before the schedule repeats
        """
        schedule = self.measurement_schedule
        return len(schedule) if schedule else 1


class HoneycombCode(FloquetCode):
    """
    Honeycomb Floquet Code.
    
    A dynamical code on a honeycomb lattice where measurements cycle
    through X-X, Y-Y, and Z-Z checks. The effective stabilizers are
    plaquettes that emerge from the measurement sequence.
    
    For static representation, we use the emergent stabilizers.
    
    Parameters
    ----------
    rows : int
        Number of rows in the honeycomb lattice
    cols : int
        Number of columns in the honeycomb lattice
    """
    
    def __init__(
        self,
        rows: int = 2,
        cols: int = 3,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """Construct a honeycomb Floquet code on a rows × cols lattice.

        Parameters
        ----------
        rows : int
            Number of rows in the honeycomb lattice (must be ≥ 2).  Default 2.
        cols : int
            Number of columns (must be ≥ 2).  Default 3.
        metadata : dict, optional
            Extra key/value pairs merged into the code's metadata dict.

        Raises
        ------
        ValueError
            If ``rows < 2`` or ``cols < 2``.
        """
        if rows < 2 or cols < 2:
            raise ValueError("Honeycomb code requires at least 2x2 layout")
        
        # Honeycomb lattice: 2 qubits per unit cell
        n_cells = rows * cols
        n_qubits = 2 * n_cells
        
        def cell_idx(r: int, c: int) -> Tuple[int, int]:
            """Get qubit indices for cell (r, c)."""
            cell = (r % rows) * cols + (c % cols)
            return (2 * cell, 2 * cell + 1)
        
        # In honeycomb, each hexagon plaquette is a stabilizer
        # For a finite lattice, we have (rows-1) * (cols-1) plaquettes approx
        
        x_stabs = []
        z_stabs = []
        
        # Simplified stabilizer structure for finite patch
        # Each plaquette involves 6 qubits
        for r in range(rows - 1):
            for c in range(cols - 1):
                # Collect qubits around a plaquette
                q1, q2 = cell_idx(r, c)
                q3, q4 = cell_idx(r, c + 1)
                q5, q6 = cell_idx(r + 1, c)
                q7, q8 = cell_idx(r + 1, c + 1)
                
                # X stabilizer
                x_stab = [0] * n_qubits
                for q in [q1, q4, q5, q8]:
                    if q < n_qubits:
                        x_stab[q] = 1
                x_stabs.append(x_stab)
                
                # Z stabilizer (offset pattern)
                z_stab = [0] * n_qubits
                for q in [q2, q3, q6, q7]:
                    if q < n_qubits:
                        z_stab[q] = 1
                z_stabs.append(z_stab)
        
        # Ensure we have at least one stabilizer
        if not x_stabs:
            x_stabs = [[1, 1] + [0] * (n_qubits - 2)]
        if not z_stabs:
            z_stabs = [[0, 0, 1, 1] + [0] * (n_qubits - 4)] if n_qubits >= 4 else [[1, 1] + [0] * (n_qubits - 2)]
        
        hx = np.array(x_stabs, dtype=np.uint8)
        hz = np.array(z_stabs, dtype=np.uint8)
        
        # Compute logical operators using CSS prescription
        # For Floquet codes, the ISG may not satisfy CSS constraint,
        # but we try the computation anyway and fallback if it fails
        try:
            log_x_vecs, log_z_vecs = compute_css_logicals(hx, hz)
            logical_x = vectors_to_paulis_x(log_x_vecs) if log_x_vecs else [{0: 'X'}]
            logical_z = vectors_to_paulis_z(log_z_vecs) if log_z_vecs else [{0: 'Z'}]
        except Exception as e:
            warnings.warn(f"Logical operator derivation failed for Honeycomb_{rows}x{cols}: {e}")
            # Floquet codes may have non-commuting ISG - use simple fallback
            logical_x = [{0: 'X'}]
            logical_z = [{0: 'Z'}]
        
        meta = dict(metadata or {})
        meta["name"] = f"Honeycomb_{rows}x{cols}"
        meta["n"] = n_qubits
        meta["k"] = 1
        meta["distance"] = min(rows, cols)  # Distance from lattice dimensions
        meta["rows"] = rows
        meta["cols"] = cols
        meta["type"] = "floquet"
        meta["measurement_schedule"] = ["XX", "YY", "ZZ"]  # Honeycomb measurement cycle
        # 17 standard metadata keys
        meta["code_family"] = "floquet"
        meta["code_type"] = "honeycomb"
        meta["rate"] = 1.0 / n_qubits if n_qubits > 0 else 0.0
        meta["lx_pauli_type"] = "X"
        meta["lx_support"] = sorted(logical_x[0].keys()) if logical_x and isinstance(logical_x[0], dict) else None
        meta["lz_pauli_type"] = "Z"
        meta["lz_support"] = sorted(logical_z[0].keys()) if logical_z and isinstance(logical_z[0], dict) else None
        meta["stabiliser_schedule"] = {
            "x_rounds": {0: 0},
            "z_rounds": {0: 0},
            "n_rounds": 3,
            "description": (
                "3-periodic Floquet schedule: round 1 = XX checks on "
                "r-edges, round 2 = YY checks on g-edges, round 3 = ZZ "
                "checks on b-edges. Effective stabilisers emerge after "
                "one full period."
            ),
        }
        meta["x_schedule"] = None
        meta["z_schedule"] = None
        meta["error_correction_zoo_url"] = "https://errorcorrectionzoo.org/c/honeycomb"
        meta["wikipedia_url"] = None
        meta["canonical_references"] = [
            "Hastings & Haah, 'Dynamically Generated Logical Qubits' (2021)",
            "Gidney, Newman & Brooks, 'Benchmarking the Planar Honeycomb Code' (2022)",
        ]
        meta["connections"] = [
            "Honeycomb lattice with 3-periodic XX/YY/ZZ measurement schedule",
            "Equivalent to surface code via schedule-dependent ISG",
            "Inherently fault-tolerant: no ancilla qubits needed",
        ]

        # Coordinate metadata
        honeycomb_data_coords: List[Tuple[float, float]] = []
        for r in range(rows):
            for c in range(cols):
                honeycomb_data_coords.append((2.0 * c, 2.0 * r))
                honeycomb_data_coords.append((2.0 * c + 1.0, 2.0 * r + 0.5))
        meta.setdefault("data_coords", honeycomb_data_coords)
        hc_dc = meta["data_coords"]
        x_stab_coords_list = []
        for row in hx:
            support = np.where(row)[0]
            if len(support) > 0:
                cx = float(np.mean([hc_dc[q][0] for q in support if q < len(hc_dc)]))
                cy = float(np.mean([hc_dc[q][1] for q in support if q < len(hc_dc)]))
                x_stab_coords_list.append((cx, cy))
            else:
                x_stab_coords_list.append((0.0, 0.0))
        meta.setdefault("x_stab_coords", x_stab_coords_list)
        z_stab_coords_list = []
        for row in hz:
            support = np.where(row)[0]
            if len(support) > 0:
                cx = float(np.mean([hc_dc[q][0] for q in support if q < len(hc_dc)]))
                cy = float(np.mean([hc_dc[q][1] for q in support if q < len(hc_dc)]))
                z_stab_coords_list.append((cx, cy))
            else:
                z_stab_coords_list.append((0.0, 0.0))
        meta.setdefault("z_stab_coords", z_stab_coords_list)
        
        super().__init__(hx=hx, hz=hz, logical_x=logical_x, logical_z=logical_z, metadata=meta)

    # ------------------------------------------------------------------
    # Gold-standard properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:  # type: ignore[override]
        """Human-readable name, e.g. ``'Honeycomb_3x3'``."""
        rows = self._metadata.get("rows", "?")
        cols = self._metadata.get("cols", "?")
        return f"Honeycomb_{rows}x{cols}"

    @property
    def distance(self) -> int:  # type: ignore[override]
        """Code distance ``min(rows, cols)``."""
        return self._metadata.get("distance", 1)

    def qubit_coords(self) -> List:
        """Return 2-D coordinates of data qubits on the honeycomb lattice."""
        rows = self._metadata.get("rows", 2)
        cols = self._metadata.get("cols", 3)
        coords: List[Tuple[float, float]] = []
        for r in range(rows):
            for c in range(cols):
                # Two qubits per unit cell, offset in y
                coords.append((2.0 * c, 2.0 * r))
                coords.append((2.0 * c + 1.0, 2.0 * r + 0.5))
        return coords


class ISGFloquetCode(FloquetCode):
    """
    Instantaneous Stabilizer Group (ISG) Floquet Code.
    
    A general Floquet code framework where the ISG changes each round
    but has a periodic structure. This is the static representation
    of the accumulated stabilizer group.
    
    Parameters
    ----------
    base_distance : int
        Target code distance
    """
    
    def __init__(
        self,
        base_distance: int = 3,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """Construct an ISG Floquet code with target distance *d*.

        Parameters
        ----------
        base_distance : int
            Target code distance (must be ≥ 2).  Default 3.
        metadata : dict, optional
            Extra key/value pairs merged into the code's metadata dict.

        Raises
        ------
        ValueError
            If ``base_distance < 2``.
        """
        d = base_distance
        
        # For ISG codes, we create a triangular-like structure
        # n qubits arranged to give distance d
        n_qubits = d * (d + 1) // 2 + d
        n_qubits = max(n_qubits, 4)  # At least 4 qubits
        
        # Create a simple stabilizer structure
        n_x_stabs = d
        n_z_stabs = d
        
        x_stabs = []
        z_stabs = []
        
        # X stabilizers
        for i in range(n_x_stabs):
            stab = [0] * n_qubits
            start = (i * 2) % n_qubits
            for j in range(2):
                stab[(start + j) % n_qubits] = 1
            x_stabs.append(stab)
        
        # Z stabilizers (offset)
        for i in range(n_z_stabs):
            stab = [0] * n_qubits
            start = (i * 2 + 1) % n_qubits
            for j in range(2):
                stab[(start + j) % n_qubits] = 1
            z_stabs.append(stab)
        
        hx = np.array(x_stabs, dtype=np.uint8)
        hz = np.array(z_stabs, dtype=np.uint8)
        
        # Compute logical operators using CSS prescription
        try:
            log_x_vecs, log_z_vecs = compute_css_logicals(hx, hz)
            logical_x = vectors_to_paulis_x(log_x_vecs) if log_x_vecs else [{0: 'X'}]
            logical_z = vectors_to_paulis_z(log_z_vecs) if log_z_vecs else [{0: 'Z'}]
        except Exception as e:
            warnings.warn(f"Logical operator derivation failed for ISGFloquet_d{d}: {e}")
            # ISG codes may have non-commuting stabilizers - fallback
            logical_x = [{0: 'X'}]
            logical_z = [{0: 'Z'}]
        
        meta = dict(metadata or {})
        meta["name"] = f"ISGFloquet_d{d}"
        meta["n"] = n_qubits
        meta["k"] = 1
        meta["distance"] = d
        meta["type"] = "floquet_isg"
        # ISG codes typically alternate between X and Z check measurements
        meta["measurement_schedule"] = ["XX", "ZZ"]
        # 17 standard metadata keys
        meta["code_family"] = "floquet"
        meta["code_type"] = "isg_floquet"
        meta["rate"] = 1.0 / n_qubits if n_qubits > 0 else 0.0
        meta["lx_pauli_type"] = "X"
        meta["lx_support"] = sorted(logical_x[0].keys()) if logical_x and isinstance(logical_x[0], dict) else None
        meta["lz_pauli_type"] = "Z"
        meta["lz_support"] = sorted(logical_z[0].keys()) if logical_z and isinstance(logical_z[0], dict) else None
        meta["stabiliser_schedule"] = {
            "x_rounds": {0: 0},
            "z_rounds": {0: 0},
            "n_rounds": 2,
            "description": (
                "2-periodic Floquet schedule: round 1 = XX check "
                "measurements, round 2 = ZZ check measurements. "
                "ISG alternates between X- and Z-dominated groups."
            ),
        }
        meta["x_schedule"] = None
        meta["z_schedule"] = None
        meta["error_correction_zoo_url"] = "https://errorcorrectionzoo.org/c/floquet_color"
        meta["wikipedia_url"] = None
        meta["canonical_references"] = [
            "Hastings & Haah, 'Dynamically Generated Logical Qubits' (2021)",
        ]
        meta["connections"] = [
            "Instantaneous Stabilizer Group (ISG) Floquet code",
            "ISG changes each round but has periodic structure",
        ]

        # Coordinate metadata
        cols_grid = int(np.ceil(np.sqrt(n_qubits)))
        isg_data_coords = [(float(i % cols_grid), float(i // cols_grid)) for i in range(n_qubits)]
        meta.setdefault("data_coords", isg_data_coords)
        isg_dc = meta["data_coords"]
        x_stab_coords_list = []
        for row in hx:
            support = np.where(row)[0]
            if len(support) > 0:
                cx = float(np.mean([isg_dc[q][0] for q in support if q < len(isg_dc)]))
                cy = float(np.mean([isg_dc[q][1] for q in support if q < len(isg_dc)]))
                x_stab_coords_list.append((cx, cy))
            else:
                x_stab_coords_list.append((0.0, 0.0))
        meta.setdefault("x_stab_coords", x_stab_coords_list)
        z_stab_coords_list = []
        for row in hz:
            support = np.where(row)[0]
            if len(support) > 0:
                cx = float(np.mean([isg_dc[q][0] for q in support if q < len(isg_dc)]))
                cy = float(np.mean([isg_dc[q][1] for q in support if q < len(isg_dc)]))
                z_stab_coords_list.append((cx, cy))
            else:
                z_stab_coords_list.append((0.0, 0.0))
        meta.setdefault("z_stab_coords", z_stab_coords_list)
        
        super().__init__(hx=hx, hz=hz, logical_x=logical_x, logical_z=logical_z, metadata=meta)

    # ------------------------------------------------------------------
    # Gold-standard properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:  # type: ignore[override]
        """Human-readable name, e.g. ``'ISGFloquet_d5'``."""
        d = self._metadata.get("distance", "?")
        return f"ISGFloquet_d{d}"

    @property
    def distance(self) -> int:  # type: ignore[override]
        """Target code distance."""
        return self._metadata.get("distance", 1)


# Pre-built instances
Honeycomb2x3 = lambda: HoneycombCode(rows=2, cols=3)
Honeycomb3x3 = lambda: HoneycombCode(rows=3, cols=3)
ISGFloquet3 = lambda: ISGFloquetCode(base_distance=3)
