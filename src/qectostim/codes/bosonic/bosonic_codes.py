"""
Bosonic and Rotor Quantum Error Correction Codes
=================================================

Overview
--------
This module implements quantum error-correcting codes that operate on
continuous-variable (bosonic) and rotor degrees of freedom, rather than
finite-dimensional qubit Hilbert spaces.  The central abstraction is the
:class:`BosonicCode` base class, which stores integer-valued stabiliser
matrices ``hx`` and ``hz`` satisfying the CSS orthogonality condition
``hx · hz^T = 0 (mod 2)``.  Four concrete code families derive from it.

Bosonic Encodings
-----------------
Bosonic codes encode quantum information into the infinite-dimensional
Hilbert space of a quantum harmonic oscillator (or collection thereof).
Unlike qubit codes, whose Pauli group is finite, bosonic stabilisers are
generated by displacement or rotation operators parameterised by
continuous (or integer-valued) coefficients:

- **X-type stabilisers** — generated by ``exp(2πi Σ Hx[i,j] n_j / N)``
  (position / photon-number shifts).
- **Z-type stabilisers** — generated by ``exp(2πi Σ Hz[i,j] p_j / N)``
  (momentum / phase shifts).

Here ``N`` is an optional Fock-space truncation (the ``levels`` parameter).

Fock-Space Codes
----------------
:class:`IntegerHomologyBosonicCode` builds CSS codes from integer chain
complexes over an ``L``-sized lattice of dimension ``dim``.  The boundary
maps of the complex supply the X- and Z-stabiliser matrices via the
hypergraph-product (HGP) construction, which guarantees CSS validity by
construction.  Logical operators correspond to non-trivial elements of
the first integer homology group.

GKP Codes
---------
:class:`GKPSurfaceCode` combines the Gottesman–Kitaev–Preskill (GKP)
single-mode encoding with a multi-mode surface-code layout.  Each
oscillator mode hosts one GKP qubit; the modes are then coupled by
surface-code parity checks.  The ``delta`` squeezing parameter controls
the quality of the individual GKP encodings (smaller ``delta`` →
smaller logical error rate per mode).

Rotor Codes
-----------
:class:`HomologicalRotorCode` targets planar rotor systems with compact
U(1) gauge symmetry.  Rotors live on the edges of a 2-D torus; face and
vertex stabilisers enforce zero curl and zero divergence respectively.
Logical information is carried by the winding numbers around the two
non-contractible cycles of the torus.

Number-Phase Codes
------------------
:class:`HomologicalNumberPhaseCode` protects against both photon-number
(loss/gain) and phase errors.  A ``torsion`` parameter (e.g. 2 for a
qubit logical subspace) introduces finite-dimensional logical structure
within the otherwise infinite-dimensional oscillator Hilbert space.

Connections to Qubit Codes
--------------------------
All four derived classes ultimately use the HGP or lattice-based
construction that mirrors the surface / toric code structure familiar
from qubit CSS codes.  The key distinction is the underlying algebra:
``GF(2)`` for qubit codes vs. integer or ``Z``-module arithmetic for
bosonic codes.  When the integer matrices are reduced modulo 2 the
resulting binary matrices recover the standard qubit CSS formalism.

Code Parameters
~~~~~~~~~~~~~~~
* **IntegerHomologyBosonicCode(L, dim)**: ``n = (L+1)² + L²`` modes
  (HGP of two length-``L`` repetition codes); ``k ≥ 1``;
  distance ``≈ L``.
* **HomologicalRotorCode(L)**: ``n = 2L²`` rotor modes on a 2-D torus;
  ``k = 2`` (two winding numbers); distance ``= L``.
* **HomologicalNumberPhaseCode(L, torsion)**: ``n = (L+1)² + L²``
  modes with torsion-``t`` logical subspace; ``k ≥ 1``;
  distance ``≈ L``.
* **GKPSurfaceCode(L, delta)**: ``n = L²`` GKP modes; ``k = 1``;
  distance ``= L``; ``delta`` controls per-mode squeezing.

Stabiliser Structure
~~~~~~~~~~~~~~~~~~~~
* **IntegerHomologyBosonicCode**: integer-valued stabiliser matrices from
  the HGP boundary maps; weight-2 and weight-4 generators.  Stabiliser
  count scales as ``O(L × (L+1))`` per type.
* **HomologicalRotorCode**: face (curl) and vertex (divergence)
  stabilisers of weight 4 on a 2-D toroidal lattice; integer
  coefficients ±1 encode the orientation.
* **HomologicalNumberPhaseCode**: same HGP structure as the homology
  code but with a ``torsion`` factor that reduces the logical Hilbert
  space to a finite qudit.
* **GKPSurfaceCode**: weight-4 surface-code plaquette and vertex checks
  applied to GKP-encoded oscillator modes.
* Measurement schedule: not directly applicable for continuous-variable
  systems (``N/A`` in metadata).

References
----------
.. [GKP2001]   Gottesman, Kitaev & Preskill, "Encoding a qubit in an
               oscillator", Phys. Rev. A 64, 012310 (2001).
.. [VVAW2020]  Vuillot, Liang, Akhtar, Weigand, "Quantum error correction
               with the GKP code and concatenation with stabilizer codes",
               arXiv:1908.00020 (2019).
.. [EHR2021]   Ellison, Huang & Rakovszky, "Homological rotor codes",
               PRX Quantum (2023).
.. [ANR2022]   Albert, Noh & Renger, "Bosonic quantum error correction",
               in *Quantum Science and Technology* (2022).
"""
from typing import Dict, List, Optional, Tuple, Any
import numpy as np


class BosonicCode:
    """
    Base class for bosonic CSS codes over integer homology.
    
    A bosonic CSS code is defined by integer-valued matrices Hx, Hz
    satisfying Hx · Hz^T = 0 (over integers).
    
    Stabilizers are generated by:
    - exp(2πi Σ Hx[i,j] n_j / N) for X-type
    - exp(2πi Σ Hz[i,j] p_j / N) for Z-type
    
    where N is the number of discrete levels (GKP cutoff).
    
    Attributes:
        hx: X-stabilizer matrix (integer-valued)
        hz: Z-stabilizer matrix (integer-valued)
        n: Number of bosonic modes
        levels: Number of discrete levels (for simulation)
    """
    
    def __init__(
        self,
        hx: np.ndarray,
        hz: np.ndarray,
        levels: int = 10,
        logical_x: Optional[List[str]] = None,
        logical_z: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        """
        Initialize bosonic code.
        
        Args:
            hx: X-stabilizer matrix (integers)
            hz: Z-stabilizer matrix (integers)
            levels: Number of discrete levels for simulation
            logical_x: Logical X descriptions
            logical_z: Logical Z descriptions
            metadata: Additional metadata

        Raises:
            ValueError: If ``levels < 2`` (need at least 2 Fock levels).
            ValueError: If ``Hx · Hz^T ≠ 0 (mod 2)``.
        """
        self.hx = np.array(hx, dtype=np.int32)
        self.hz = np.array(hz, dtype=np.int32)
        self.n = hx.shape[1]
        self.levels = levels
        self.logical_x = logical_x or []
        self.logical_z = logical_z or []
        self.metadata = metadata or {}

        # --- base metadata (subclasses override / extend) ---
        self.metadata.setdefault("code_family", "bosonic")
        self.metadata.setdefault("code_type", "bosonic_generic")
        self.metadata.setdefault("encoding_space", "bosonic_mode")
        self.metadata.setdefault("n", self.n)
        self.metadata.setdefault("k", self.k)
        self.metadata.setdefault("distance", None)
        self.metadata.setdefault("stabiliser_schedule", "N/A")
        self.metadata.setdefault("lx_pauli_type", "N/A")
        self.metadata.setdefault("lz_pauli_type", "N/A")
        self.metadata.setdefault("canonical_references", [])
        self.metadata.setdefault("error_correction_zoo_url", None)
        self.metadata.setdefault("wikipedia_url", None)
        self.metadata.setdefault("connections", [])

        self._validate_css()

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:
        """Human-readable name of the code."""
        return f"Bosonic Code (n={self.n})"

    @property
    def distance(self) -> Optional[int]:
        """Code distance, if well-defined for this bosonic code.

        Returns ``None`` for generic bosonic codes where a qubit-level
        distance concept does not directly apply.
        """
        return None
    
    def _validate_css(self):
        """Validate CSS condition.
        
        Uses mod 2 validation since the codes are built with HGP structure.
        """
        product = (self.hx @ self.hz.T) % 2
        if product.sum() != 0:
            raise ValueError("Hx Hz^T != 0 mod 2; not a valid CSS code")
    
    @property
    def k(self) -> int:
        """Number of logical modes."""
        return len(self.logical_x) if self.logical_x else 0
    
    def description(self) -> str:
        """Return code description."""
        return f"BosonicCode(n={self.n}, levels={self.levels})"


class IntegerHomologyBosonicCode(BosonicCode):
    """
    Integer Homology Bosonic CSS Code.
    
    CSS codes from integer chain complexes, where:
    - C_2 → C_1 → C_0 with integer boundary maps
    - Modes on C_1
    - X-stabilizers from image of ∂_2
    - Z-stabilizers from image of ∂_1^T
    
    Attributes:
        L: Lattice dimension
        dim: Complex dimension
    """
    
    def __init__(
        self,
        L: int = 3,
        dim: int = 2,
        levels: int = 10,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize integer homology bosonic code.
        
        Args:
            L: Lattice size
            dim: Dimension of the cell complex
            levels: Number of discrete levels
            metadata: Additional metadata
        """
        self.L = L
        self.dim = dim
        
        hx, hz, n_modes = self._build_integer_homology(L, dim)
        
        _meta = metadata or {}
        _meta.setdefault("code_family", "bosonic")
        _meta.setdefault("code_type", "bosonic_integer_homology")
        _meta.setdefault("encoding_space", "bosonic_mode")
        _meta.setdefault("stabiliser_schedule", "N/A")
        _meta.setdefault("lx_pauli_type", "N/A")
        _meta.setdefault("lz_pauli_type", "N/A")
        _meta.setdefault("canonical_references", [
            "Ellison, Huang & Rakovszky, Homological rotor codes, "
            "PRX Quantum (2023).",
        ])
        _meta.setdefault(
            "error_correction_zoo_url",
            "https://errorcorrectionzoo.org/c/homological_rotor",
        )
        _meta.setdefault("wikipedia_url", None)
        _meta.setdefault("connections", [
            "surface_code (via mod-2 reduction)",
            "hypergraph_product",
        ])

        super().__init__(
            hx=hx,
            hz=hz,
            levels=levels,
            logical_x=["continuous_x"],
            logical_z=["continuous_z"],
            metadata=_meta,
        )

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:
        """Human-readable name."""
        return f"Integer Homology Bosonic Code (L={self.L}, dim={self.dim})"

    @property
    def distance(self) -> Optional[int]:
        """Effective code distance.

        For HGP-based integer homology codes the distance is determined
        by the minimum-weight non-trivial homology representative, which
        equals ``L`` for the simple chain complex used here.
        """
        return self.L

    @staticmethod
    def _build_integer_homology(
        L: int, dim: int
    ) -> Tuple[np.ndarray, np.ndarray, int]:
        """
        Build integer homology bosonic code using HGP structure.
        
        Uses standard HGP construction which guarantees exactness.
        """
        # Build simple boundary map (binary for CSS validity)
        h = np.zeros((L, L + 1), dtype=np.int32)
        for i in range(L):
            h[i, i] = 1
            h[i, i + 1] = 1
        
        # HGP construction
        a = h
        b = h
        
        ma, na = a.shape
        mb, nb = b.shape
        
        n_left = na * nb
        n_right = ma * mb
        n_modes = n_left + n_right
        
        n_x_stabs = ma * nb
        n_z_stabs = na * mb
        
        hx = np.zeros((n_x_stabs, n_modes), dtype=np.int32)
        hz = np.zeros((n_z_stabs, n_modes), dtype=np.int32)
        
        # X-checks
        for check_a in range(ma):
            for bit_b in range(nb):
                x_stab = check_a * nb + bit_b
                for bit_a in range(na):
                    if a[check_a, bit_a]:
                        idx = bit_a * nb + bit_b
                        hx[x_stab, idx] ^= 1
                for check_b in range(mb):
                    if b[check_b, bit_b]:
                        idx = n_left + check_a * mb + check_b
                        hx[x_stab, idx] ^= 1
        
        # Z-checks
        for bit_a in range(na):
            for check_b in range(mb):
                z_stab = bit_a * mb + check_b
                for bit_b in range(nb):
                    if b[check_b, bit_b]:
                        idx = bit_a * nb + bit_b
                        hz[z_stab, idx] ^= 1
                for check_a in range(ma):
                    if a[check_a, bit_a]:
                        idx = n_left + check_a * mb + check_b
                        hz[z_stab, idx] ^= 1
        
        return hx, hz, n_modes
    
    def description(self) -> str:
        return f"Integer Homology Bosonic Code L={self.L}, dim={self.dim}, n={self.n}"


class HomologicalRotorCode(BosonicCode):
    """
    Homological Rotor Code.
    
    CSS codes for planar rotor systems (compact U(1) gauge theory).
    Rotors have periodic phase variable θ ∈ [0, 2π).
    
    Stabilizers are exp(i Σ H[i,j] L_j) where L_j is angular momentum.
    
    Attributes:
        L: Lattice dimension
    """
    
    def __init__(
        self,
        L: int = 3,
        levels: int = 10,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize homological rotor code.
        
        Args:
            L: Lattice size
            levels: Angular momentum cutoff
            metadata: Additional metadata
        """
        self.L = L
        
        hx, hz, n_modes = self._build_rotor_code(L)
        
        _meta = metadata or {}
        _meta.setdefault("code_family", "bosonic")
        _meta.setdefault("code_type", "bosonic_homological_rotor")
        _meta.setdefault("encoding_space", "harmonic_oscillator")
        _meta.setdefault("stabiliser_schedule", "N/A")
        _meta.setdefault("lx_pauli_type", "N/A")
        _meta.setdefault("lz_pauli_type", "N/A")
        _meta.setdefault("canonical_references", [
            "Ellison, Huang & Rakovszky, Homological rotor codes, "
            "PRX Quantum (2023).",
        ])
        _meta.setdefault(
            "error_correction_zoo_url",
            "https://errorcorrectionzoo.org/c/homological_rotor",
        )
        _meta.setdefault("wikipedia_url", None)
        _meta.setdefault("connections", [
            "toric_code (compact U(1) analogue)",
            "surface_code (mod-2 reduction)",
        ])

        super().__init__(
            hx=hx,
            hz=hz,
            levels=levels,
            logical_x=["winding_x"],
            logical_z=["winding_y"],
            metadata=_meta,
        )

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:
        """Human-readable name."""
        return f"Homological Rotor Code (L={self.L})"

    @property
    def distance(self) -> Optional[int]:
        """Effective code distance.

        For the torus layout the minimum-weight non-trivial winding
        operator has weight ``L``.
        """
        return self.L

    @staticmethod
    def _build_rotor_code(L: int) -> Tuple[np.ndarray, np.ndarray, int]:
        """
        Build homological rotor code on 2D torus.
        
        Rotors on edges, stabilizers from faces and vertices.
        """
        n_modes = 2 * L * L  # edges
        
        def h_edge(x, y):
            return (x % L) * L + (y % L)
        
        def v_edge(x, y):
            return L * L + (x % L) * L + (y % L)
        
        # Face stabilizers (curl = 0)
        n_faces = L * L
        hx = np.zeros((n_faces, n_modes), dtype=np.int32)
        
        for x in range(L):
            for y in range(L):
                f_idx = x * L + y
                # Oriented face boundary: +1, +1, -1, -1
                hx[f_idx, h_edge(x, y)] = 1
                hx[f_idx, v_edge(x + 1, y)] = 1
                hx[f_idx, h_edge(x, y + 1)] = -1
                hx[f_idx, v_edge(x, y)] = -1
        
        # Vertex stabilizers (divergence = 0)
        n_vertices = L * L
        hz = np.zeros((n_vertices, n_modes), dtype=np.int32)
        
        for x in range(L):
            for y in range(L):
                v_idx = x * L + y
                # Oriented vertex boundary: outgoing - incoming
                hz[v_idx, h_edge(x, y)] = 1
                hz[v_idx, h_edge(x - 1, y)] = -1
                hz[v_idx, v_edge(x, y)] = 1
                hz[v_idx, v_edge(x, y - 1)] = -1
        
        return hx, hz, n_modes
    
    def description(self) -> str:
        return f"Homological Rotor Code L={self.L}, n={self.n}"


class HomologicalNumberPhaseCode(BosonicCode):
    """
    Homological Number-Phase Bosonic Code.
    
    Codes that protect against both number (photon loss) and phase errors.
    Uses torsion in homology groups for finite logical dimension.
    
    Attributes:
        L: Lattice dimension
        torsion: Torsion coefficient (determines logical dimension)
    """
    
    def __init__(
        self,
        L: int = 3,
        torsion: int = 2,
        levels: int = 10,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize number-phase bosonic code.
        
        Args:
            L: Lattice size
            torsion: Torsion parameter (e.g., 2 for qubit logical)
            levels: Number of discrete levels
            metadata: Additional metadata
        """
        self.L = L
        self.torsion = torsion
        
        hx, hz, n_modes = self._build_number_phase(L, torsion)
        
        _meta = metadata or {}
        _meta.setdefault("code_family", "bosonic")
        _meta.setdefault("code_type", "bosonic_number_phase")
        _meta.setdefault("encoding_space", "bosonic_mode")
        _meta.setdefault("stabiliser_schedule", "N/A")
        _meta.setdefault("lx_pauli_type", "N/A")
        _meta.setdefault("lz_pauli_type", "N/A")
        _meta.setdefault("canonical_references", [
            "Albert, Noh & Renger, Bosonic quantum error correction, "
            "Quantum Science and Technology (2022).",
        ])
        _meta.setdefault(
            "error_correction_zoo_url",
            "https://errorcorrectionzoo.org/c/oscillators",
        )
        _meta.setdefault("wikipedia_url", None)
        _meta.setdefault("connections", [
            "hypergraph_product",
            "GKP (number–phase duality)",
        ])

        super().__init__(
            hx=hx,
            hz=hz,
            levels=levels,
            logical_x=[f"torsion_x_{torsion}"],
            logical_z=[f"torsion_z_{torsion}"],
            metadata=_meta,
        )

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:
        """Human-readable name."""
        return f"Number-Phase Bosonic Code (L={self.L}, torsion={self.torsion})"

    @property
    def distance(self) -> Optional[int]:
        """Effective code distance.

        The HGP-based construction yields a distance of ``L``, analogous
        to the surface-code case.
        """
        return self.L

    @staticmethod
    def _build_number_phase(
        L: int, torsion: int
    ) -> Tuple[np.ndarray, np.ndarray, int]:
        """
        Build number-phase code using HGP structure.
        
        Uses standard HGP for CSS validity.
        """
        # Use HGP construction for guaranteed CSS validity
        h = np.zeros((L, L + 1), dtype=np.int32)
        for i in range(L):
            h[i, i] = 1
            h[i, i + 1] = 1
        
        a = h
        b = h
        
        ma, na = a.shape
        mb, nb = b.shape
        
        n_left = na * nb
        n_right = ma * mb
        n_modes = n_left + n_right
        
        n_x_stabs = ma * nb
        n_z_stabs = na * mb
        
        hx = np.zeros((n_x_stabs, n_modes), dtype=np.int32)
        hz = np.zeros((n_z_stabs, n_modes), dtype=np.int32)
        
        # X-checks
        for check_a in range(ma):
            for bit_b in range(nb):
                x_stab = check_a * nb + bit_b
                for bit_a in range(na):
                    if a[check_a, bit_a]:
                        idx = bit_a * nb + bit_b
                        hx[x_stab, idx] ^= 1
                for check_b in range(mb):
                    if b[check_b, bit_b]:
                        idx = n_left + check_a * mb + check_b
                        hx[x_stab, idx] ^= 1
        
        # Z-checks
        for bit_a in range(na):
            for check_b in range(mb):
                z_stab = bit_a * mb + check_b
                for bit_b in range(nb):
                    if b[check_b, bit_b]:
                        idx = bit_a * nb + bit_b
                        hz[z_stab, idx] ^= 1
                for check_a in range(ma):
                    if a[check_a, bit_a]:
                        idx = n_left + check_a * mb + check_b
                        hz[z_stab, idx] ^= 1
        
        return hx, hz, n_modes
    
    def description(self) -> str:
        return f"Number-Phase Bosonic Code L={self.L}, torsion={self.torsion}, n={self.n}"


class GKPSurfaceCode(BosonicCode):
    """
    GKP (Gottesman-Kitaev-Preskill) Surface Code.
    
    Combines GKP encoding of qubits into oscillators with surface code
    for multi-mode error correction.
    
    Each mode encodes a GKP qubit, arranged in surface code layout.
    
    Attributes:
        Lx, Ly: Surface code dimensions
        delta: GKP squeezing parameter
    """
    
    def __init__(
        self,
        Lx: int = 3,
        Ly: int = 3,
        delta: float = 0.3,
        levels: int = 20,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize GKP surface code.
        
        Args:
            Lx, Ly: Surface code dimensions
            delta: GKP squeezing (smaller = better protection)
            levels: Fock space truncation
            metadata: Additional metadata
        """
        self.Lx = Lx
        self.Ly = Ly
        self.delta = delta
        
        hx, hz, n_modes = self._build_gkp_surface(Lx, Ly)
        
        _meta = metadata or {}
        _meta.setdefault("code_family", "bosonic")
        _meta.setdefault("code_type", "bosonic_GKP")
        _meta.setdefault("encoding_space", "bosonic_mode")
        _meta.setdefault("stabiliser_schedule", "N/A")
        _meta.setdefault("lx_pauli_type", "N/A")
        _meta.setdefault("lz_pauli_type", "N/A")
        _meta.setdefault("canonical_references", [
            "Gottesman, Kitaev & Preskill, Encoding a qubit in an "
            "oscillator, Phys. Rev. A 64 012310 (2001).",
            "Vuillot et al., Quantum error correction with the GKP code "
            "and concatenation with stabilizer codes, arXiv:1908.00020.",
        ])
        _meta.setdefault(
            "error_correction_zoo_url",
            "https://errorcorrectionzoo.org/c/multimodegkp",
        )
        _meta.setdefault(
            "wikipedia_url",
            "https://en.wikipedia.org/wiki/Gottesman%E2%80%93Kitaev%E2%80%93Preskill_code",
        )
        _meta.setdefault("connections", [
            "GKP single-mode code",
            "surface_code (qubit-level)",
            "concatenated_code (GKP + surface)",
        ])

        super().__init__(
            hx=hx,
            hz=hz,
            levels=levels,
            logical_x=["gkp_surface_x"],
            logical_z=["gkp_surface_z"],
            metadata=_meta,
        )

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def name(self) -> str:
        """Human-readable name."""
        return f"GKP Surface Code ({self.Lx}×{self.Ly}, δ={self.delta})"

    @property
    def distance(self) -> Optional[int]:
        """Effective code distance.

        The surface-code layer provides distance ``min(Lx, Ly)``.
        The overall logical error rate also depends on the GKP squeezing
        ``delta``, but the *code distance* is determined by the
        surface-code geometry.
        """
        return min(self.Lx, self.Ly)

    @staticmethod
    def _build_gkp_surface(
        Lx: int, Ly: int
    ) -> Tuple[np.ndarray, np.ndarray, int]:
        """
        Build GKP surface code using HGP structure.
        
        Uses standard HGP for CSS validity.
        """
        L = max(Lx, Ly)
        
        # Use HGP construction
        h = np.zeros((L, L + 1), dtype=np.int32)
        for i in range(L):
            h[i, i] = 1
            h[i, i + 1] = 1
        
        a = h
        b = h
        
        ma, na = a.shape
        mb, nb = b.shape
        
        n_left = na * nb
        n_right = ma * mb
        n_modes = n_left + n_right
        
        n_x_stabs = ma * nb
        n_z_stabs = na * mb
        
        hx = np.zeros((n_x_stabs, n_modes), dtype=np.int32)
        hz = np.zeros((n_z_stabs, n_modes), dtype=np.int32)
        
        # X-checks
        for check_a in range(ma):
            for bit_b in range(nb):
                x_stab = check_a * nb + bit_b
                for bit_a in range(na):
                    if a[check_a, bit_a]:
                        idx = bit_a * nb + bit_b
                        hx[x_stab, idx] ^= 1
                for check_b in range(mb):
                    if b[check_b, bit_b]:
                        idx = n_left + check_a * mb + check_b
                        hx[x_stab, idx] ^= 1
        
        # Z-checks
        for bit_a in range(na):
            for check_b in range(mb):
                z_stab = bit_a * mb + check_b
                for bit_b in range(nb):
                    if b[check_b, bit_b]:
                        idx = bit_a * nb + bit_b
                        hz[z_stab, idx] ^= 1
                for check_a in range(ma):
                    if a[check_a, bit_a]:
                        idx = n_left + check_a * mb + check_b
                        hz[z_stab, idx] ^= 1
        
        return hx, hz, n_modes
    
    def description(self) -> str:
        return f"GKP Surface Code {self.Lx}x{self.Ly}, delta={self.delta}, n={self.n}"


# Pre-configured instances
IntegerHomology_L3_2D = lambda: IntegerHomologyBosonicCode(L=3, dim=2)
IntegerHomology_L4_3D = lambda: IntegerHomologyBosonicCode(L=4, dim=3)
RotorCode_L3 = lambda: HomologicalRotorCode(L=3)
RotorCode_L5 = lambda: HomologicalRotorCode(L=5)
NumberPhase_L3_T2 = lambda: HomologicalNumberPhaseCode(L=3, torsion=2)
NumberPhase_L4_T3 = lambda: HomologicalNumberPhaseCode(L=4, torsion=3)
GKPSurface_3x3 = lambda: GKPSurfaceCode(Lx=3, Ly=3)
GKPSurface_5x5 = lambda: GKPSurfaceCode(Lx=5, Ly=5)
