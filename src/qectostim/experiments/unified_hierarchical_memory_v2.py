# src/qectostim/experiments/unified_hierarchical_memory_v2.py
"""
Unified Hierarchical Concatenated Code Memory Experiment V2.

This module provides UnifiedHierarchicalMemoryV2, a thin orchestration layer
that combines:
- LogicalBlockManagerV2 (segment tracking for decoder)
- OuterStabilizerEngineV3 (FT outer stabilizer measurement)
- LogicalGateDispatcher (gate method selection)

HierarchicalV6Decoder 4-Phase Architecture
==========================================

The stim circuit generated by this experiment contains ONLY raw operations.
The HierarchicalV6Decoder implements a 4-phase pipeline:

  Phase 1: Inner Error Inference
    - For each inner_ec segment, decode syndrome pattern
    - Supports 'temporal' (MWPM) or 'majority_vote' modes
    - Output: inner_z_correction[seg_id], inner_x_correction[seg_id]
    - X ancillas detect Z errors → Z correction
    - Z ancillas detect X errors → X correction

  Phase 2: Correct Outer Syndrome  
    - Apply ancilla inner corrections to raw outer syndrome
    - Each outer_stab segment has ancilla_ec_segment_ids
    - X stabilizers (anc measured Z): use inner_x_correction
    - Z stabilizers (anc measured X): use inner_z_correction

  Phase 3: Correct Data Logicals
    - Apply ALL inner corrections to final data measurements
    - data_block_to_all_ec_segments provides cumulative mapping
    - Z basis: cumulative XOR of inner_z_correction
    - X basis: cumulative XOR of inner_x_correction

  Phase 4: Outer Temporal DEM Decode
    - Consecutive round comparison: D[r,s] = S[r+1,s] XOR S[r,s]
    - Final boundary detectors compare last syndrome to data
    - PyMatching decode → final logical prediction

Key Features:
=============

1. **Clean Component Delegation**: Experiment is a thin orchestrator that
   delegates to specialized components for block management, scheduling,
   and gate emission.

2. **Parallel X+Z Stabilizers**: When possible, measures X and Z outer
   stabilizers simultaneously using doubled ancilla pools.

3. **FT Structure**: Supports inner_ec_between_gates for fault-tolerant
   protocol with inner EC between logical gate layers.

4. **Segment-Based Decoder Metadata**: Provides complete mappings for
   HierarchicalV6Decoder 4-phase pipeline.

Architecture:
=============

┌─────────────────────────────────────────────────────────────────────────────┐
│                     UnifiedHierarchicalMemoryV2                             │
│                      (Thin Orchestration Layer)                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Configuration:                                                             │
│    • inner_code, outer_code                                                 │
│    • rounds, inner_rounds_per_outer                                         │
│    • measurement_basis, initial_state                                       │
│    • gate_method, inner_ec_between_gates                                    │
│    • noise_model                                                            │
│                                                                             │
│  Components (created in to_stim):                                           │
│    • LogicalBlockManagerV2 - block allocation, segment tracking             │
│    • OuterStabilizerEngineV3 - FT protocol with ancilla EC tracking         │
│    • LogicalGateDispatcher - gate method selection                          │
│                                                                             │
│  Phase Orchestration:                                                       │
│    1. _emit_initialization()                                                │
│    2. _emit_memory_rounds()                                                 │
│    3. _emit_final_measurement()                                             │
│    4. _emit_observable()                                                    │
│                                                                             │
│  Decoder Metadata (for HierarchicalV6Decoder 4-phase pipeline):             │
│    • segment_metadata: All inner_ec and outer_stab segments                 │
│    • data_block_to_all_ec_segments: Cumulative EC mapping for Phase 3       │
│    • ancilla_logical_measurements: Maps outer stabs to meas indices         │
│    • stab_to_ancilla_block: Maps outer stabs to ancilla block IDs           │
│    • final_data_measurements: Per-block final measurement indices           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Example Usage:
==============
>>> from qectostim.codes.small import SteaneCode, RepetitionCode
>>> from qectostim.experiments.unified_hierarchical_memory_v2 import (
...     UnifiedHierarchicalMemoryV2
... )
>>>
>>> inner_code = SteaneCode()  # [[7,1,3]] code
>>> outer_code = RepetitionCode(3)  # [[3,1,3]] repetition
>>>
>>> experiment = UnifiedHierarchicalMemoryV2(
...     inner_code=inner_code,
...     outer_code=outer_code,
...     rounds=5,
...     inner_rounds_per_outer=2,
...     inner_ec_between_gates=True,
... )
>>> circuit = experiment.to_stim()
"""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Tuple,
    TYPE_CHECKING,
)

import numpy as np
import stim

from qectostim.codes.abstract_code import Code
from qectostim.experiments.experiment import Experiment
from qectostim.experiments.stabilizer_rounds import (
    DetectorContext,
    StabilizerBasis,
    get_logical_support,
)
from qectostim.experiments.logical_block_manager_v2 import LogicalBlockManagerV2
from qectostim.experiments.outer_stabilizer_engine_v3 import OuterStabilizerEngineV3
from qectostim.experiments.logical_gate_dispatcher import (
    LogicalGateDispatcher,
    GateMethod,
)
from qectostim.noise.models import NoiseModel
from qectostim.experiments.measurement_model import (
    FinalDataMeasurement,
    MeasurementCentricMetadata,
)



@dataclass
class HierarchicalMemoryMetadataV2:
    """
    Metadata for hierarchical memory experiment V2.
    
    Provides information for hierarchical decoder integration.
    """
    # Code parameters
    inner_code_name: str
    outer_code_name: str
    n_inner: int
    k_inner: int
    d_inner: int
    n_outer: int
    k_outer: int
    d_outer: int
    
    # Block structure
    n_data_blocks: int
    n_x_ancilla_blocks: int
    n_z_ancilla_blocks: int
    n_total_qubits: int
    
    # Experiment parameters
    rounds: int
    inner_rounds_per_outer: int
    measurement_basis: str
    initial_state: str
    gate_method: str
    inner_ec_between_gates: bool
    emit_observable: bool = True  # Whether OBSERVABLE_INCLUDE was emitted


class UnifiedHierarchicalMemoryV2(Experiment):
    """
    Unified hierarchical concatenated code memory experiment.
    
    This experiment implements proper hierarchical concatenation with:
    - Parallel X+Z outer stabilizer measurement
    - Optional inner EC between logical gates
    - Segment-based metadata for HierarchicalV6Decoder 4-phase pipeline
    
    HierarchicalV6Decoder Integration
    ==================================
    The experiment emits raw operations only. The decoder implements:
    
    Phase 1: Inner Error Inference
      - Decode each inner_ec segment (temporal or majority_vote mode)
      - X ancillas detect Z errors → inner_z_correction
      - Z ancillas detect X errors → inner_x_correction
      
    Phase 2: Correct Outer Syndrome
      - Apply ancilla corrections using ancilla_ec_segment_ids per gadget
      - X stabilizers: use inner_x_correction
      - Z stabilizers: use inner_z_correction
      
    Phase 3: Correct Data Logicals  
      - Apply cumulative corrections via data_block_to_all_ec_segments
      - Z basis: XOR all inner_z_correction for each data block
      - X basis: XOR all inner_x_correction for each data block
      
    Phase 4: Outer Temporal DEM Decode
      - Consecutive comparison: D[r,s] = S[r+1,s] XOR S[r,s]
      - Final boundary detectors compare last syndrome to data
      - PyMatching for final prediction
    
    Parameters
    ----------
    inner_code : Code
        The code used for each inner block. Should be CSS for full support.
    outer_code : Code
        The code whose stabilizers are measured using logical gates.
    noise_model : NoiseModel, optional
        Noise model to apply.
    outer_rounds : int
        Number of outer stabilizer measurement rounds.
    inner_rounds_per_outer : int
        Number of inner EC rounds between each outer operation.
    measurement_basis : str
        Final measurement basis ("Z" or "X").
    initial_state : str
        Initial logical state ("0", "1", "+", "-").
    gate_method : GateMethod
        Method for logical gate implementation.
    inner_ec_between_gates : bool
        Whether to run inner EC between logical gates within outer stabilizer.
    metadata : Dict[str, Any], optional
        Additional metadata.
    """
    
    def __init__(
        self,
        inner_code: Code,
        outer_code: Code,
        noise_model: Optional[NoiseModel] = None,
        outer_rounds: int = 3,
        inner_rounds_per_outer: int = 1,
        measurement_basis: str = "Z",
        initial_state: str = "0",
        gate_method: GateMethod = GateMethod.AUTO,
        inner_ec_between_gates: bool = True,
        emit_observable: bool = True,  # NEW: Option 3 support
        metadata: Optional[Dict[str, Any]] = None,
    ):
        # Store codes
        self._inner_code = inner_code
        self._outer_code = outer_code

        # Cache the last built circuit so decoders/notebooks can access the
        # exact measurement ordering used to generate metadata.
        self._last_circuit: Optional[stim.Circuit] = None
        
        # Initialize base class
        super().__init__(
            code=inner_code,  # Use inner code as primary reference
            noise_model=noise_model,
            metadata=metadata or {},
        )
        
        # Validate codes
        self._validate_codes()
        
        # Store parameters
        self._outer_rounds = outer_rounds
        self._inner_rounds_per_outer = inner_rounds_per_outer
        self._measurement_basis = measurement_basis.upper()
        self._initial_state = initial_state
        self._gate_method = gate_method
        self._inner_ec_between_gates = inner_ec_between_gates
        self._emit_observable = emit_observable  # NEW: Option 3 support
        
        # Compute block counts
        self._n_data_blocks = outer_code.n
        
        # Ancilla pool sizes (doubled for parallel X+Z)
        hx_outer = getattr(outer_code, 'hx', None)
        hz_outer = getattr(outer_code, 'hz', None)
        n_x_outer = hx_outer.shape[0] if hx_outer is not None and hasattr(hx_outer, 'shape') and hx_outer.size > 0 else 0
        n_z_outer = hz_outer.shape[0] if hz_outer is not None and hasattr(hz_outer, 'shape') and hz_outer.size > 0 else 0
        self._n_x_ancilla_blocks = max(n_x_outer, 1)
        self._n_z_ancilla_blocks = max(n_z_outer, 1)
        
        # Components (created lazily in to_stim)
        self._ctx: Optional[DetectorContext] = None
        self._block_manager: Optional[LogicalBlockManagerV2] = None
        self._gate_dispatcher: Optional[LogicalGateDispatcher] = None
        self._outer_engine: Optional[OuterStabilizerEngineV3] = None  
        
        # Track measurements for observable
        self._final_measurement_indices: Dict[int, List[int]] = {}
        
        # Experiment metadata
        self._experiment_metadata: Optional[HierarchicalMemoryMetadataV2] = None
    
    def _validate_codes(self) -> None:
        """Validate codes for hierarchical concatenation."""
        inner = self._inner_code
        outer = self._outer_code
        
        # Inner code must encode at least 1 logical qubit
        if inner.k < 1:
            raise ValueError(
                f"Inner code must encode at least 1 logical qubit, got k={inner.k}"
            )
        
        # Warn if not CSS
        if not (hasattr(inner, 'is_css') and inner.is_css):
            import warnings
            warnings.warn(
                f"Inner code {inner} is not CSS. Some features may not work correctly.",
                UserWarning
            )
        
        if not (hasattr(outer, 'is_css') and outer.is_css):
            import warnings
            warnings.warn(
                f"Outer code {outer} is not CSS. Some features may not work correctly.",
                UserWarning
            )
    
    # =========================================================================
    # Properties
    # =========================================================================
    
    @property
    def inner_code(self) -> Code:
        """The inner code used for each block."""
        return self._inner_code
    
    @property
    def outer_code(self) -> Code:
        """The outer code whose stabilizers are measured."""
        return self._outer_code
    
    @property
    def outer_rounds(self) -> int:
        """Number of outer stabilizer measurement rounds."""
        return self._outer_rounds
    
    # Backwards compatibility alias
    @property
    def rounds(self) -> int:
        """Alias for outer_rounds (deprecated, use outer_rounds instead)."""
        return self._outer_rounds
    
    @property
    def n_data_blocks(self) -> int:
        """Number of data blocks (= n_outer)."""
        return self._n_data_blocks
    
    @property
    def total_physical_qubits(self) -> int:
        """Total number of physical qubits across all blocks."""
        inner = self._inner_code
        hx = getattr(inner, 'hx', None)
        hz = getattr(inner, 'hz', None)
        n_x_stabs = hx.shape[0] if hx is not None and hasattr(hx, 'shape') and hx.size > 0 else 0
        n_z_stabs = hz.shape[0] if hz is not None and hasattr(hz, 'shape') and hz.size > 0 else 0
        
        qubits_per_block = inner.n + n_x_stabs + n_z_stabs
        total_blocks = self._n_data_blocks + self._n_x_ancilla_blocks + self._n_z_ancilla_blocks
        return qubits_per_block * total_blocks
    
    @property
    def experiment_metadata(self) -> Optional[HierarchicalMemoryMetadataV2]:
        """Get experiment metadata (available after to_stim())."""
        return self._experiment_metadata
    
    # =========================================================================
    # Main Circuit Generation
    # =========================================================================
    
    def to_stim(self) -> stim.Circuit:
        """
        Generate the complete Stim circuit.
        
        Returns
        -------
        stim.Circuit
            The complete circuit with noise applied (if noise model provided).
        """
        circuit = stim.Circuit()
        
        # Initialize components
        self._initialize_components()
        
        # Build circuit phases
        self._emit_initialization(circuit)
        self._emit_memory_rounds(circuit)
        self._emit_final_measurement(circuit)
        
        # Conditionally emit observable (Option 3: emit_observable=False)
        if self._emit_observable:
            self._emit_observable_include(circuit)
        
        # Build metadata
        self._build_metadata()
        
        # Apply noise model if provided
        if self.noise_model is not None:
            circuit = self.noise_model.apply(circuit)

        # Cache for downstream decoder tooling.
        self._last_circuit = circuit
        return circuit
    
    def _initialize_components(self) -> None:
        """Initialize all components."""
        # Detector context
        self._ctx = DetectorContext()
    
        # Block manager
        self._block_manager = LogicalBlockManagerV2(
            inner_code=self._inner_code,
            n_data_blocks=self._n_data_blocks,
            n_x_ancilla_blocks=self._n_x_ancilla_blocks,
            n_z_ancilla_blocks=self._n_z_ancilla_blocks,
            measurement_basis=self._measurement_basis,
        )
        
        # Set outer stabilizer counts in MCM
        # The outer code determines how many X and Z stabilizers we have
        mcm = self._block_manager.get_measurement_centric_metadata()
        # Support both lowercase (hx, hz) and uppercase (Hx, Hz) attribute names
        outer_hx = getattr(self._outer_code, 'hx', None)
        if outer_hx is None:
            outer_hx = getattr(self._outer_code, 'Hx', None)
        outer_hz = getattr(self._outer_code, 'hz', None)
        if outer_hz is None:
            outer_hz = getattr(self._outer_code, 'Hz', None)
        inner_hx = getattr(self._inner_code, 'hx', None)
        if inner_hx is None:
            inner_hx = getattr(self._inner_code, 'Hx', None)
        inner_hz = getattr(self._inner_code, 'hz', None)
        if inner_hz is None:
            inner_hz = getattr(self._inner_code, 'Hz', None)
        
        mcm.n_x_stabs_outer = outer_hx.shape[0] if outer_hx is not None else 0
        mcm.n_z_stabs_outer = outer_hz.shape[0] if outer_hz is not None else 0
        mcm.n_x_stabs_inner = inner_hx.shape[0] if inner_hx is not None else 0
        mcm.n_z_stabs_inner = inner_hz.shape[0] if inner_hz is not None else 0
        
        # Gate dispatcher
        self._gate_dispatcher = LogicalGateDispatcher(
            inner_code=self._inner_code,
            default_method=self._gate_method,
        )
        
        # Get inner code distance for inner rounds
        inner_d = max(getattr(self._inner_code, 'd', 3), 3)
        
        # Outer stabilizer engine (V3 - external syndrome computation by decoder)
        # Pass inner_rounds = inner code distance for proper temporal error detection
        # Engine always measures BOTH X and Z stabilizers (both needed for error detection)
        self._outer_engine = OuterStabilizerEngineV3(
            outer_code=self._outer_code,
            block_manager=self._block_manager,
            gate_dispatcher=self._gate_dispatcher,
            inner_rounds=inner_d,
        )
    
    # =========================================================================
    # Phase Emission
    # =========================================================================
    
    def _emit_initialization(self, circuit: stim.Circuit) -> None:
        """
        Emit circuit initialization.
        
        1. QUBIT_COORDS for all qubits
        2. Reset all qubits
        3. Prepare initial logical state
        4. Initial inner EC segment (establish detector baseline)
        
        The initial EC segment uses the new emit_inner_ec_segment() method
        which properly aggregates d rounds with TICKs between them.
        """
        # 1. Emit qubit coordinates
        self._block_manager.emit_qubit_coords(circuit)
        
        # 2. Reset all blocks
        all_block_ids = list(range(
            self._n_data_blocks + self._n_x_ancilla_blocks + self._n_z_ancilla_blocks
        ))
        self._block_manager.emit_reset_blocks(circuit, all_block_ids)
        circuit.append("TICK")
   
        # 3. Prepare initial logical state on data blocks
        self._prepare_initial_state(circuit)
        circuit.append("TICK")
        
        # 4. Initial inner EC segment (establish baseline)
        # Use the new emit_inner_ec_segment method which:
        # - Creates ONE InnerECInstance per block with n_rounds measurements
        # - Inserts TICKs between rounds for temporal error detection
        d = max(getattr(self._inner_code, 'd', 3), 3)
        
        # Emit EC segment on all blocks with d rounds
        self._block_manager.emit_inner_ec_segment_all_blocks(
            circuit,
            n_rounds=d,
            context='init',
            outer_round=-1,
        )
    
    def _prepare_initial_state(self, circuit: stim.Circuit) -> None:
        """Prepare initial logical state on all data blocks."""
        for block_id in range(self._n_data_blocks):
            if self._initial_state == "0":
                # |0⟩ is already prepared by reset
                pass
            elif self._initial_state == "1":
                self._block_manager.emit_prepare_logical_one(circuit, block_id)
            elif self._initial_state == "+":
                self._block_manager.emit_prepare_logical_plus(circuit, block_id)
            elif self._initial_state == "-":
                self._block_manager.emit_prepare_logical_minus(circuit, block_id)
            else:
                raise ValueError(f"Unknown initial state: {self._initial_state}")
    
    def _emit_memory_rounds(self, circuit: stim.Circuit) -> None:
        """
        Emit main memory rounds using MCM architecture.
        
        Architecture (per outer round):
        1. Inner EC segment (pre) - d rounds on DATA blocks 0-6
        2. Parallel outer stabilizers - all 6 outer stabilizers simultaneously
        3. Inner EC segment (post) - d rounds on DATA blocks 0-6
        
        MCM Architecture:
        - ONE InnerECInstance per (block, segment) with all d rounds
        - TICKs between syndrome rounds for temporal error detection
        - OuterSyndromeValue created per stabilizer per round
        - No legacy segment tracking - MCM metadata only
        """
        d = max(getattr(self._inner_code, 'd', 3), 3)  # Distance for inner EC rounds
        
        for round_idx in range(self._outer_rounds):
            circuit.append("TICK")
            
            # 1. Inner EC segment (pre) - BEFORE outer stabilizers
            # Uses segment-based emission with d rounds and proper TICKs
            self._block_manager.emit_inner_ec_segment_data_blocks(
                circuit,
                n_rounds=d,
                context='pre_outer',
                outer_round=round_idx,
            )
            
            # 2. Parallel outer stabilizers - all 6 stabilizers simultaneously
            # Leading/trailing EC use ancilla blocks 7-12 with d rounds each
            self._outer_engine.emit_parallel_outer_stabilizers(
                circuit,
                round_idx=round_idx,
                inner_rounds=d,
            )
            
            # 3. Inner EC segment (post) - AFTER outer stabilizers
            # Uses segment-based emission with d rounds and proper TICKs
            self._block_manager.emit_inner_ec_segment_data_blocks(
                circuit,
                n_rounds=d,
                context='post_outer',
                outer_round=round_idx,
            )
    
    def _emit_final_measurement(self, circuit: stim.Circuit) -> None:
        """
        Emit final measurement of all data blocks.
        
        1. Final inner EC segment (data blocks only)
        2. Measure all data blocks in specified basis
        3. Add FinalDataMeasurement entries to MCM metadata
        """
        # Final inner EC segment - uses segment-based emission
        d = max(getattr(self._inner_code, 'd', 3), 3)
        self._block_manager.emit_inner_ec_segment_data_blocks(
            circuit,
            n_rounds=d,
            context='final',
            outer_round=self._outer_rounds,
        )
        
        # Measure all data blocks
        self._final_measurement_indices = self._block_manager.emit_final_data_measurement(
            circuit,
            basis=self._measurement_basis,
        )
        
        # Add FinalDataMeasurement entries to measurement-centric metadata
        metadata = self._block_manager.get_measurement_centric_metadata()
        for block_id, meas_indices in self._final_measurement_indices.items():
            final_meas = FinalDataMeasurement(
                block_id=block_id,
                transversal_meas_indices=meas_indices,
                measurement_basis=self._measurement_basis,
            )
            metadata.add_final_measurement(final_meas)
    
    def _emit_observable_include(self, circuit: stim.Circuit) -> None:
        """
        Emit OBSERVABLE_INCLUDE for the outer logical operator.
        
        The outer logical is the tensor product of inner logical operators
        according to the outer code's logical operator support.

        """
        self._block_manager.emit_logical_observable(
            circuit,
            outer_code=self._outer_code,
            final_measurements=self._final_measurement_indices,
            basis=self._measurement_basis,
            observable_idx=0,
        )
    
    # =========================================================================
    # Metadata
    # =========================================================================
    
    def _build_metadata(self) -> None:
        """Build experiment metadata for decoder integration."""
        self._experiment_metadata = HierarchicalMemoryMetadataV2(
            # Code parameters
            inner_code_name=str(self._inner_code),
            outer_code_name=str(self._outer_code),
            n_inner=self._inner_code.n,
            k_inner=self._inner_code.k,
            d_inner=getattr(self._inner_code, 'd', 1),
            n_outer=self._outer_code.n,
            k_outer=self._outer_code.k,
            d_outer=getattr(self._outer_code, 'd', 1),
            
            # Block structure
            n_data_blocks=self._n_data_blocks,
            n_x_ancilla_blocks=self._n_x_ancilla_blocks,
            n_z_ancilla_blocks=self._n_z_ancilla_blocks,
            n_total_qubits=self.total_physical_qubits,
            
            # Experiment parameters
            rounds=self._outer_rounds,
            inner_rounds_per_outer=self._inner_rounds_per_outer,
            measurement_basis=self._measurement_basis,
            initial_state=self._initial_state,
            gate_method=self._gate_method.name if hasattr(self._gate_method, 'name') else str(self._gate_method),
            inner_ec_between_gates=self._inner_ec_between_gates,
            emit_observable=self._emit_observable
        )
    
    def get_decoder_metadata(self) -> Dict[str, Any]:
        """
        Get complete metadata for hierarchical decoder.
        
        This provides all information needed by HierarchicalV3/V4/V5Decoder:
        - Code objects and structure
        - Block information with qubit ranges
        - Outer stabilizer measurement tracking
        - Detector-to-block mapping
        - Final measurement indices
        - Entanglement history (for V5 decoder)
        
        Returns
        -------
        Dict[str, Any]
            Complete metadata for hierarchical decoding.
        """
        if self._experiment_metadata is None:
            raise RuntimeError("Metadata not available. Call to_stim() first.")
        
        # Get outer logical support for decoder
        outer_z_support = list(get_logical_support(self._outer_code, "Z", 0))
        outer_x_support = list(get_logical_support(self._outer_code, "X", 0))
        
        return {
            # Core code objects
            'inner_code': self._inner_code,
            'outer_code': self._outer_code,

            # Optional: the exact circuit used to generate this metadata.
            # This enables measurement->detector conversion or DEM extraction
            # in decoders without changing notebook workflows.
            'circuit': self._last_circuit,
            
            # Block counts
            'n_data_blocks': self._n_data_blocks,
            'n_ancilla_blocks': self._n_x_ancilla_blocks + self._n_z_ancilla_blocks,
            'n_x_ancilla_blocks': self._n_x_ancilla_blocks,
            'n_z_ancilla_blocks': self._n_z_ancilla_blocks,
            'qubits_per_block': self._block_manager.qubits_per_block,
            
            # Experiment parameters
            'rounds': self._outer_rounds,  # Renamed from self._rounds
            'outer_rounds': self._outer_rounds,  # Explicit new name
            'measurement_basis': self._measurement_basis,
            'emit_observable': self._emit_observable,
            
            # Block structure (qubit ranges per block)
            'block_info': self._block_manager.get_block_info_dict(),
            
            # Outer stabilizer measurements
            # Key: (round_idx, stab_type, stab_idx) -> [measurement_indices]
            'ancilla_logical_measurements': self._outer_engine.ancilla_logical_measurements,
            
            # Outer stabilizer support
            # Key: (stab_type, stab_idx) -> [data_block_ids]
            'outer_stab_support': self._outer_engine.get_outer_stab_support(),
            
            # Stabilizer to ancilla block mapping
            # Key: (stab_type, stab_idx) -> ancilla_block_id
            # This is CRITICAL for the decoder to know which block to use
            'stab_to_ancilla_block': self._outer_engine.get_stab_to_ancilla_block(),
            
            # Inner stabilizer measurements (CRITICAL for V5 decoder)
            # Key: block_id -> {'x_anc': [meas_indices], 'z_anc': [meas_indices]}
            'inner_stabilizer_measurements': self._block_manager.get_inner_stabilizer_measurements(),
            
            # DEPRECATED: segment_metadata removed in V6 refactor
            # Use 'measurement_centric_metadata' instead which provides:
            #   - inner_ec_instances: All EC instances with measurement indices
            #   - outer_syndrome_values: Outer measurements with ancilla_ec_instance_id
            #   - final_data_measurements: Final data measurements
            # Legacy decoders can reconstruct segment info from MCM if needed.
            
            # Final measurement indices for data blocks
            # Key: block_id -> [measurement_indices]
            'final_logical_measurements': self._final_measurement_indices,
            'final_data_measurements': self._final_measurement_indices,  # Alias
            
            # Outer logical support (for V5 decoder)
            'outer_logical_support': {
                'Z': outer_z_support,
                'X': outer_x_support,
            },
            
            # NEW: Measurement-centric metadata for V6+ decoder
            # =====================================================
            # This is the new format that directly maps to decoder needs:
            # - inner_ec_instances: All EC instances with measurement indices
            # - block_to_ec_instances: Block -> [instance_ids] mapping
            # - outer_syndrome_values: Outer measurements with ancilla_ec_instance_id
            # - final_data_measurements: Final data measurements
            'measurement_centric_metadata': self._block_manager.get_measurement_centric_metadata().to_dict(),
            
        }
    
    def get_summary(self) -> str:
        """Get human-readable summary of the experiment."""
        lines = [
            f"UnifiedHierarchicalMemoryV2",
            f"  Inner code: {self._inner_code} [[{self._inner_code.n},{self._inner_code.k},{getattr(self._inner_code, 'd', '?')}]]",
            f"  Outer code: {self._outer_code} [[{self._outer_code.n},{self._outer_code.k},{getattr(self._outer_code, 'd', '?')}]]",
            f"  Data blocks: {self._n_data_blocks}",
            f"  X ancilla blocks: {self._n_x_ancilla_blocks}",
            f"  Z ancilla blocks: {self._n_z_ancilla_blocks}",
            f"  Total qubits: {self.total_physical_qubits}",
            f"  Outer rounds: {self._outer_rounds}",
            f"  Inner rounds/outer: {self._inner_rounds_per_outer}",
            f"  Measurement basis: {self._measurement_basis}",
            f"  Gate method: {self._gate_method}",
            f"  Inner EC between gates: {self._inner_ec_between_gates}",
        ]
        
        if self._outer_engine is not None:
            lines.append(f"  Can interleave X+Z: {self._outer_engine.can_interleave()}")
        
        return "\n".join(lines)
